<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Chat - Chế độ Học tập</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.6/dist/purify.min.js"></script>
    <script>
        // Set theme based on localStorage or system preference
        if (localStorage.getItem('color-theme') === 'dark' || (!('color-theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    </script>
    <style>
        /* Custom scrollbar styles */
        :root {
            --scrollbar-track-bg: #f1f1f1;
            --scrollbar-thumb-bg: #888;
            --scrollbar-thumb-hover-bg: #555;
        }
        .dark {
            --scrollbar-track-bg: #2d3748;
            --scrollbar-thumb-bg: #718096;
            --scrollbar-thumb-hover-bg: #a0aec0;
        }
        body {
            overflow-x: hidden;
        }
        #chat-container::-webkit-scrollbar, #reference-content::-webkit-scrollbar, #sidebar-content::-webkit-scrollbar, #summary-content::-webkit-scrollbar {
            width: 6px;
        }
        #chat-container::-webkit-scrollbar-track, #reference-content::-webkit-scrollbar-track, #sidebar-content::-webkit-scrollbar-track, #summary-content::-webkit-scrollbar-track {
            background: var(--scrollbar-track-bg);
        }
        #chat-container::-webkit-scrollbar-thumb, #reference-content::-webkit-scrollbar-thumb, #sidebar-content::-webkit-scrollbar-thumb, #summary-content::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb-bg);
            border-radius: 6px;
        }
        #chat-container::-webkit-scrollbar-thumb:hover, #reference-content::-webkit-scrollbar-thumb:hover, #sidebar-content::-webkit-scrollbar-thumb:hover, #summary-content::-webkit-scrollbar-thumb:hover {
            background: var(--scrollbar-thumb-hover-bg);
        }
        /* Markdown rendering styles */
        .message-content pre { background-color: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; font-family: 'Courier New', Courier, monospace; }
        .dark .message-content pre { background-color: #0f172a; }
        .message-content code:not(pre > code) { background-color: #e2e8f0; color: #1e293b; padding: 0.2em 0.4em; margin: 0; font-size: 85%; border-radius: 3px; }
        .dark .message-content code:not(pre > code) { background-color: #334155; color: #e2e8f0; }
        .message-content h1, .message-content h2, .message-content h3, .message-content h4 { font-weight: 600; margin-top: 1rem; margin-bottom: 0.5rem; }
        .message-content h1 { font-size: 1.5em; }
        .message-content h2 { font-size: 1.25em; }
        .message-content h3 { font-size: 1.1em; }
        .message-content p { margin-bottom: 0.75rem; }
        .message-content ul, .message-content ol { margin-left: 1.25rem; margin-top: 0.5rem; margin-bottom: 1rem; display: block; }
        .message-content ul { list-style-type: disc; }
        .message-content ol { list-style-type: decimal; }
        .message-content li { margin-bottom: 0.5rem; padding-left: 0.5rem; }
        .message-content a { color: #3b82f6; text-decoration: underline; }
        .dark .message-content a { color: #60a5fa; }
        .message-content blockquote { border-left: 4px solid #d1d5db; padding-left: 1rem; margin: 1rem 0; color: #4b5563; font-style: italic; }
        .dark .message-content blockquote { border-left-color: #4b5563; color: #9ca3af; }
        /* Note and Summary specific styles */
        .note-wrapper { margin-top: 1rem; margin-bottom: 1rem; padding: 1rem; border-radius: 0.5rem; border-width: 1px; background-color: #fefce8; border-color: #fde68a; }
        .dark .note-wrapper { background-color: #1e293b; border-color: #334155; }
        .note-header { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.25rem; font-weight: 600; color: #92400e; }
        .dark .note-header { color: #fcd34d; }
        .note-content { color: #374151; }
        .dark .note-content { color: #d1d5db; }
        .summary-wrapper { margin-top: 1rem; margin-bottom: 1rem; padding: 1rem; border-radius: 0.5rem; border-width: 1px; background-color: #faf5ff; border-color: #e9d5ff; }
        .dark .summary-wrapper { background-color: #3b0764; border-color: #5b21b6; }
        .summary-header { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.25rem; font-weight: 600; color: #7e22ce; }
        .dark .summary-header { color: #c084fc; }
        .summary-content { color: #374151; }
        .dark .summary-content { color: #d1d5db; }
        /* Interactive links for learning mode and terms */
        .term-link, .learning-link { color: #2563eb; font-weight: 600; border-bottom: 2px dotted #93c5fd; cursor: pointer; transition: color 0.2s, border-color 0.2s; text-decoration: none; }
        .dark .term-link, .dark .learning-link { color: #60a5fa; border-bottom-color: #3b82f6; }
        .term-link:hover, .learning-link:hover { color: #1d4ed8; border-bottom-color: #2563eb; background-color: #eef2ff; }
        .dark .term-link:hover, .dark .learning-link:hover { color: #93c5fd; border-bottom-color: #60a5fa; background-color: #374151;}
        .ai-status { font-size: 0.875rem; line-height: 1.25rem; font-weight: 600; color: #2563eb; padding-right: 0.5rem; }
        .dark .ai-status { color: #60a5fa; }
        /* Persona selection screen improvements */
        #persona-selection-screen { -ms-overflow-style: none; scrollbar-width: none; }
        #persona-selection-screen::-webkit-scrollbar { display: none; }
        .persona-card { transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out; position: relative; }
        .persona-card:hover { transform: translateY(-5px); box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); }
        .dark .persona-card:hover { box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.3), 0 4px 6px -4px rgb(0 0 0 / 0.3); }
        .skeleton-box { @apply bg-gray-200 dark:bg-gray-700 rounded animate-pulse; }
        .blinking-cursor { display: inline-block; width: 8px; height: 1.2em; background-color: #333; animation: blink 1s step-end infinite; vertical-align: text-bottom; }
        .dark .blinking-cursor { background-color: #ccc; }
        @keyframes blink { from, to { background-color: transparent; } 50% { background-color: inherit; } }
        /* Sidebar transitions */
        #sidebar { transition: transform 0.3s ease-in-out; overflow: hidden; }
        #sidebar-overlay { transition: opacity 0.3s ease-in-out; }
        /* Record button animation */
        #record-btn.recording { animation: pulse-red 1s infinite; background-color: #ef4444; color: white; }
        @keyframes pulse-red { 0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); transform: scale(1); } 70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); transform: scale(1.05); } 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); transform: scale(1); } }
        /* Input area styling */
        .p-4 > #input-area-wrapper { box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04); border-radius: 9999px; padding: 4px; background-color: white; transition: box-shadow 0.2s ease-in-out; }
        .p-4 > #input-area-wrapper:focus-within { box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08); }
        .dark .p-4 > #input-area-wrapper { background-color: #1f2937; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2); }
        .dark .p-4 > #input-area-wrapper:focus-within { box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
        #sidebar-content { overflow-y: scroll; overflow-x: hidden; }
        /* Persona modal transitions */
        #persona-modal-overlay { transition: opacity 0.3s ease-in-out; }
        #persona-modal { transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out; max-height: 90vh; }
        .custom-persona-actions { position: absolute; top: 0.5rem; right: 0.5rem; opacity: 0; transition: opacity 0.2s ease-in-out; }
        .persona-card:hover .custom-persona-actions { opacity: 1; }
        /* Welcome suggestion card hover effect */
        .welcome-suggestion-card {
            transition: background-color 0.2s ease-in-out;
        }
        .welcome-suggestion-card:hover {
            background-color: #eef2ff; /* indigo-50 */
        }
        .dark .welcome-suggestion-card:hover {
            background-color: #374151; /* gray-700 */
        }
        /* Spin animation for loading indicators */
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
        .animate-spin {
          animation: spin 1s linear infinite;
        }
        /* Toast notification styles */
        .toast {
            transition: all 0.4s ease-in-out;
            opacity: 0;
            transform: translateX(100%);
        }
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast.hide {
            opacity: 0;
            transform: translateX(120%);
        }
        /* Learning Mode Toggle styling */
        #learning-mode-toggle:checked + .block + .dot {
            transform: translateX(1.5rem); /* 24px */
            background-color: #3b82f6; /* bg-blue-600 */
        }
        #learning-mode-toggle:checked + .block {
            background-color: #93c5fd; /* bg-blue-300 */
        }
        .dark #learning-mode-toggle:checked + .block + .dot {
            background-color: #60a5fa; /* bg-blue-400 */
        }
        .dark #learning-mode-toggle:checked + .block {
            background-color: #374151;
        }

        /* Scroll to Top Button Styles */
        #scrollToTopBtn {
            display: none; /* Hidden by default */
            position: absolute; /* Changed from fixed to absolute to contain within chat-container */
            bottom: 20px; /* Place at the bottom */
            right: 20px; /* Place at the right */
            z-index: 99; /* Make sure it does not overlap */
            border: none; /* Remove borders */
            outline: none; /* Remove outline */
            background-color: #3b82f6; /* Blue background */
            color: white; /* White text */
            cursor: pointer; /* Add a mouse pointer on hover */
            padding: 10px 15px; /* Some padding */
            border-radius: 50%; /* Rounded corners */
            font-size: 18px; /* Increase font size */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Add a subtle shadow */
            transition: background-color 0.3s, opacity 0.3s; /* Smooth transition */
            opacity: 0; /* Start hidden */
        }

        #scrollToTopBtn:hover {
            background-color: #2563eb; /* Darker blue on hover */
        }
        #scrollToTopBtn.show {
            opacity: 1;
            display: block;
        }
        .dark #scrollToTopBtn {
            background-color: #60a5fa;
        }
        .dark #scrollToTopBtn:hover {
            background-color: #3b82f6;
        }
    </style>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2563eb">
    <link rel="icon" href="icon-192.png">
</head>
<body class="bg-gray-100 dark:bg-gray-900 font-sans overflow-x-hidden">

    <!-- Authentication UI -->
    <div id="auth-container" class="flex items-center justify-center h-screen">
        <div class="bg-white dark:bg-gray-800 p-8 rounded-xl shadow-lg w-full max-w-md m-4">
            <div id="login-view">
                <h2 class="text-2xl font-bold text-center text-gray-800 dark:text-gray-100 mb-6">Đăng nhập</h2>
                <form id="login-form">
                    <div class="mb-4">
                        <label for="login-email" class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2">Email</label>
                        <input type="email" id="login-email" required class="shadow-sm appearance-none border dark:border-gray-600 rounded w-full py-3 px-4 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-200 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400">
                    </div>
                    <div class="mb-6">
                        <label for="login-password" class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2">Mật khẩu</label>
                        <input type="password" id="login-password" required class="shadow-sm appearance-none border dark:border-gray-600 rounded w-full py-3 px-4 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-200 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400">
                    </div>
                    <button type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors duration-200">Đăng nhập</button>
                </form>
                <div class="my-4 flex items-center">
                    <div class="flex-grow border-t border-gray-300 dark:border-gray-600"></div>
                    <span class="flex-shrink mx-4 text-gray-400 dark:text-gray-500">hoặc</span>
                    <div class="flex-grow border-t border-gray-300 dark:border-gray-600"></div>
                </div>
                <button id="google-login-btn" class="w-full bg-white dark:bg-gray-200 border border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-300 text-gray-700 font-bold py-3 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors duration-200 flex items-center justify-center">
                    <svg class="w-5 h-5 mr-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><path fill="#4285F4" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l8.1 6.28C12.09 13.42 17.63 9.5 24 9.5z"/><path fill="#34A853" d="M46.98 24.55c0-1.57-.15-3.09-.42-4.55H24v8.51h12.8c-.57 3.02-2.31 5.47-4.91 7.28l7.81 6.04C44.29 36.29 46.98 30.95 46.98 24.55z"/><path fill="#FBBC05" d="M10.66 28.14c-.58-1.74-.91-3.58-.91-5.48s.33-3.74.91-5.48l-8.1-6.28C.92 14.16 0 18.91 0 24s.92 9.84 2.56 13.22l8.1-6.08z"/><path fill="#EA4335" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.81-6.04c-2.18 1.47-4.96 2.34-8.08 2.34-6.37 0-11.91-3.92-13.84-9.3l-8.1 6.28C6.51 42.62 14.62 48 24 48z"/><path fill="none" d="M0 0h48v48H0z"/></svg>
                    Đăng nhập với Google
                </button>
                <p class="text-center mt-6 text-sm">
                    <a href="#" class="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300" id="show-register">Chưa có tài khoản? Đăng ký ngay</a>
                </p>
            </div>
            <div id="register-view" class="hidden">
                 <h2 class="text-2xl font-bold text-center text-gray-800 dark:text-gray-100 mb-6">Tạo tài khoản</h2>
                <form id="register-form">
                    <div class="mb-4">
                        <label for="register-email" class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2">Email</label>
                        <input type="email" id="register-email" required class="shadow-sm appearance-none border dark:border-gray-600 rounded w-full py-3 px-4 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-200 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400">
                    </div>
                    <div class="mb-6">
                        <label for="register-password" class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2">Mật khẩu</label>
                        <input type="password" id="register-password" required class="shadow-sm appearance-none border dark:border-gray-600 rounded w-full py-3 px-4 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-200 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400">
                    </div>
                    <button type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors duration-200">Đăng ký</button>
                </form>
                <p class="text-center mt-6 text-sm">
                    <a href="#" class="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300" id="show-login">Đã có tài khoản? Đăng nhập</a>
                </p>
            </div>
            <p id="auth-error" class="text-red-500 dark:text-red-400 text-center mt-4 min-h-[1.2em]"></p>
        </div>
    </div>

    <!-- Main App UI -->
    <div id="app-container" class="hidden h-screen flex overflow-hidden">
        <div id="sidebar-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden opacity-0 transition-opacity duration-300 ease-in-out lg:hidden"></div>
        
        <!-- Sidebar -->
        <div id="sidebar" class="fixed top-0 left-0 h-screen w-[calc(100vw-56px)] sm:w-64 md:w-72 bg-white dark:bg-slate-800 shadow-xl z-50 transform -translate-x-full flex flex-col lg:translate-x-0 lg:static lg:w-72 lg:border-r rounded-r-2xl border-gray-200 dark:border-slate-700">
            <div class="p-4 border-b border-gray-200 dark:border-slate-700 flex items-center justify-between lg:hidden">
                <h2 class="text-lg font-semibold dark:text-gray-100">Menu</h2>
                <button id="close-sidebar-btn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-slate-700">
                    <svg class="w-6 h-6 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                </button>
            </div>
            <div id="sidebar-content" class="flex-1 overflow-y-scroll overflow-x-hidden p-4">
                <button id="new-chat-btn" class="w-full flex items-center gap-3 p-3 rounded-lg border border-blue-200 dark:border-slate-600 hover:bg-blue-50 dark:hover:bg-slate-700 transition-colors text-blue-700 dark:text-blue-400 font-semibold mb-4">
                    <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M13.5 4.5a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0zm-2.5 5.5a3.5 3.5 0 100-7 3.5 3.5 0 000 7zM10 12.5a4.5 4.5 0 110-9 4.5 4.5 0 010 9zM10 16a6 6 0 100-12 6 6 0 000 12z" /></svg>
                    Chọn chuyên gia khác
                </button>
                <div id="pinned-chats-section" class="hidden">
                    <h3 class="text-sm font-semibold text-gray-500 dark:text-gray-400 mb-2 uppercase">Đã ghim</h3>
                    <ul id="pinned-chats-list" class="space-y-1 mb-4"></ul>
                </div>
                <h3 class="text-sm font-semibold text-gray-500 dark:text-gray-400 mb-2 uppercase">Gần đây</h3>
                <ul id="saved-chats-list" class="space-y-1"></ul>
                <div id="saved-chats-skeleton" class="space-y-2 mt-2 hidden">
                    <div class="h-8 bg-gray-200 dark:bg-slate-700 rounded animate-pulse w-11/12"></div>
                    <div class="h-8 bg-gray-200 dark:bg-slate-700 rounded animate-pulse w-10/12"></div>
                </div>
            </div>
        </div>
        
        <div class="flex-1 flex flex-col overflow-x-hidden">
            <!-- Persona Selection Screen -->
            <div id="persona-selection-screen" class="flex flex-col items-center h-full p-4 sm:p-6 overflow-y-auto bg-gray-50 dark:bg-slate-900">
                <h1 class="text-3xl sm:text-4xl font-bold text-gray-800 dark:text-gray-100 mb-2">Chào bạn, <span id="welcome-user-name"></span>!</h1>
                <p class="text-base sm:text-lg text-gray-600 dark:text-gray-400 mb-6 sm:mb-8">Bạn muốn bắt đầu với chuyên gia nào hôm nay?</p>
                
                <div class="w-full max-w-7xl">
                    <div class="mb-6 sm:mb-8">
                        <button id="create-persona-btn" class="w-full sm:w-auto flex items-center justify-center gap-2 px-4 py-2 sm:px-6 sm:py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition-colors">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M10.75 4.75a.75.75 0 00-1.5 0v4.5h-4.5a.75.75 0 000 1.5h4.5v4.5a.75.75 0 001.5 0v-4.5h4.5a.75.75 0 000-1.5h-4.5v-4.5z" /></svg>
                            Tạo Persona Mới
                        </button>
                    </div>

                    <div id="custom-personas-section" class="mb-10">
                        <h2 class="text-xl sm:text-2xl font-bold text-gray-700 dark:text-gray-300 mb-4 border-b pb-2 dark:border-gray-700">Persona của bạn</h2>
                        <div id="custom-persona-grid" class="grid grid-cols-2 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"></div>
                        <div id="empty-custom-persona-state" class="hidden text-center p-8 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-2xl mt-4">
                            <div class="flex justify-center mb-4">
                               <svg class="w-16 h-16 text-blue-300 dark:text-blue-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.572L16.5 21.75l-.398-1.178a3.375 3.375 0 00-2.455-2.456L12.75 18l1.178-.398a3.375 3.375 0 002.455-2.456L16.5 14.25l.398 1.178a3.375 3.375 0 002.456 2.456L20.25 18l-1.178.398a3.375 3.375 0 00-2.456 2.456z" /></svg>
                            </div>
                            <h3 class="text-xl font-semibold text-gray-700 dark:text-gray-200 mb-2">Tạo chuyên gia AI đầu tiên của bạn!</h3>
                            <p class="text-gray-500 dark:text-gray-400 max-w-sm mx-auto">Biến ý tưởng thành hiện thực bằng cách tạo ra một Persona AI với kiến thức và phong cách riêng.</p>
                        </div>
                    </div>

                    <div>
                        <h2 class="text-xl sm:text-2xl font-bold text-gray-700 dark:text-gray-300 mb-4 border-b pb-2 dark:border-gray-700">Persona mặc định</h2>
                        <div id="default-persona-grid" class="grid grid-cols-2 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"></div>
                    </div>
                </div>
                <button id="logout-btn-persona" class="mt-8 text-sm text-gray-500 hover:text-red-500 dark:hover:text-red-400 transition-colors">Đăng xuất</button>
            </div>

            <!-- Chat View Container -->
            <div id="chat-view-container" class="hidden flex-col h-full bg-gray-50 dark:bg-slate-900">
                <header id="main-header" class="flex-shrink-0 flex justify-between items-center p-3 sm:p-4 bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700">
                    <div class="flex items-center gap-3">
                        <button id="menu-btn" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors lg:hidden" title="Menu">
                            <svg class="w-6 h-6 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
                        </button>
                        <div id="chat-header-info" class="flex items-center gap-3">
                            <!-- Learning Mode Indicator is dynamically added here by JS -->
                        </div>
                        <button id="summarize-btn" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors" title="Tóm tắt cuộc trò chuyện">
                           <svg class="w-6 h-6 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M2 4.75A.75.75 0 012.75 4h14.5a.75.75 0 010 1.5H2.75A.75.75 0 012 4.75zM2 10a.75.75 0 01.75-.75h14.5a.75.75 0 010 1.5H2.75A.75.75 0 012 10zm0 5.25a.75.75 0 01.75-.75h9.5a.75.75 0 010 1.5h-9.5a.75.75 0 01-.75-.75z" clip-rule="evenodd" /></svg>
                        </button>
                        <button id="new-topic-btn" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors" title="Trò chuyện mới">
                            <svg class="w-6 h-6 text-blue-600 dark:text-blue-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" /></svg>
                        </button>
                        <!-- Learning Mode Toggle -->
                        <div class="flex items-center border-l border-gray-200 dark:border-slate-600 ml-2 pl-2">
                            <label for="learning-mode-toggle" class="flex items-center cursor-pointer" title="Bật/Tắt chế độ học tập tương tác">
                                <span class="mr-2 text-sm font-medium text-gray-700 dark:text-gray-300">Học tập</span>
                                <div class="relative">
                                    <input type="checkbox" id="learning-mode-toggle" class="sr-only">
                                    <div class="block bg-gray-200 dark:bg-slate-700 w-12 h-6 rounded-full transition-colors"></div>
                                    <div class="dot absolute left-1 top-1 bg-white dark:bg-slate-500 w-4 h-4 rounded-full transition-transform"></div>
                                </div>
                            </label>
                        </div>
                    </div>
                    
                    <div class="flex items-center gap-1 sm:gap-2">
                        <button id="theme-toggle" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors" title="Chuyển chế độ Sáng/Tối">
                            <svg id="theme-toggle-dark-icon" class="hidden w-5 h-5 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg>
                            <svg id="theme-toggle-light-icon" class="hidden w-5 h-5 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 14.95a1 1 0 010-1.414l.707-.707a1 1 0 011.414 1.414l-.707.707a1 1 0 01-1.414 0zM3 11a1 1 0 100-2H2a1 1 0 100 2h1z" clip-rule="evenodd"></path></svg>
                        </button>
                        <button id="logout-btn" class="p-2 rounded-full hover:bg-red-50 dark:hover:bg-red-900/50 transition-colors" title="Đăng xuất">
                            <svg class="w-6 h-6 text-red-500" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none" opacity=".87"/><path d="M17 7l-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5-5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4V5z"/></svg>
                        </button>
                    </div>
                </header>

                <div id="main-content" class="flex-1 flex flex-col overflow-hidden relative"> <!-- Added relative here for scroll to top button positioning -->
                    <div id="welcome-screen" class="flex-1 flex-col items-center justify-center p-4 text-center hidden">
                        <div id="welcome-persona-icon" class="text-6xl mb-4"></div>
                        <h2 id="welcome-persona-name" class="text-2xl font-bold text-gray-800 dark:text-gray-200"></h2>
                        <p id="welcome-persona-description" class="max-w-md mt-2 text-gray-600 dark:text-gray-400"></p>
                        <div id="welcome-suggestions-container" class="mt-8 w-full max-w-2xl mx-auto space-y-3">
                            <!-- Welcome suggestions will be rendered here -->
                        </div>
                    </div>
                    
                    <div id="chat-container" class="flex-1 px-4 pt-4 space-y-4 overflow-y-auto relative hidden">
                        <div id="notification-area" class="hidden sticky bottom-2 w-full flex justify-center">
                            <div class="bg-blue-100 dark:bg-slate-700 text-blue-800 dark:text-blue-200 text-xs font-semibold px-4 py-2 rounded-full shadow-lg">
                                Đang tối ưu hóa cuộc trò chuyện...
                            </div>
                        </div>
                        <!-- Scroll to Top Button -->
                        <button id="scrollToTopBtn" title="Cuộn lên đầu">
                            <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l7.5-7.5 7.5 7.5m-15 6l7.5-7.5 7.5 7.5" /></svg>
                        </button>
                    </div>

                    <div id="suggestion-area" class="px-4 pb-2">
                        <button id="toggle-suggestions-btn" class="hidden w-full text-left text-sm text-blue-600 dark:text-blue-400 font-semibold p-2 rounded-lg hover:bg-blue-50 dark:hover:bg-slate-800 flex items-center gap-2">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><g><rect fill="none" height="24" width="24"/></g><g><g><path d="M4,18h11c0.55,0,1-0.45,1-1v-2c0-0.55-0.45-1-1-1H4c-0.55,0-1,0.45-1,1v2C3,17.55,3.45,18,4,18z M3,7c0,0.55,0.45,1,1,1 h11c0.55,0,1-0.45,1-1V5c0-0.55-0.45-1-1-1H4C3.45,4,3,4.45,3,5V7z M4,13h11c0.55,0,1-0.45,1-1v-2c0-0.55-0.45-1-1-1H4 c-0.55,0-1,0.45-1,1v2C3,12.55,3.45,13,4,13z M19.5,4.5L19.5,4.5c0.47,0.47,0.47,1.23,0,1.7l-4.08,4.08 c-0.47,0.47-1.23,0.47-1.7,0l0,0c-0.47-0.47-0.47,1.23,0-1.7l4.08-4.08C18.27,4.03,19.03,4.03,19.5,4.5z M19.5,17.82 c0.47-0.47,1.23-0.47,1.7,0l0,0c0.47,0.47,0.47,1.23,0,1.7l-4.08,4.08c-0.47,0.47-1.23,0.47-1.7,0l0,0c-0.47-0.47-0.47,1.23,0-1.7 L19.5,17.82z"/></g></g></svg>
                            Xem gợi ý
                        </button>
                        <div id="suggestions-container" class="hidden mt-2 flex flex-wrap gap-2"></div>
                    </div>

                    <div class="p-4 bg-white dark:bg-slate-800 border-t border-gray-200 dark:border-slate-700">
                        <div id="input-area-wrapper" class="rounded-full">
                            <div id="input-area" class="flex items-center gap-3 bg-gray-100 dark:bg-slate-700 rounded-full p-2">
                                <button id="reference-btn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-slate-600 transition-colors" title="Trợ lý Phụ">
                                    <svg class="w-6 h-6 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><g><path d="M0,0h24v24H0V0z" fill="none"/></g><g><g><path d="M11,7h2v2h-2V7z M11,11h2v6h-2V11z M12,2C6.48,2,2,6.48,2,12s4.48,10,10,10s10-4.48,10-10S17.52,2,12,2z M12,20 c-4.41,0-8-3.59-8-8s3.59-8,8-8s8,3.59,8,8S16.41,20,12,20z"/></g></g></svg>
                                </button>
                                <textarea id="prompt-input" rows="1" placeholder="Nhập câu hỏi..." class="flex-1 bg-transparent px-3 py-2 resize-none focus:outline-none dark:text-gray-200 dark:placeholder-gray-400"></textarea>
                                <button id="record-btn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-slate-600 transition-colors" title="Ghi âm">
                                    <svg class="w-6 h-6 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
                                </button>
                                <button id="send-btn" class="w-10 h-10 flex items-center justify-center bg-blue-600 rounded-full text-white hover:bg-blue-700 transition-colors disabled:bg-blue-300 dark:disabled:bg-blue-800 disabled:cursor-not-allowed" title="Gửi">
                                    <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2 .01 7z"/></svg>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Persona Creation/Edit Modal -->
    <div id="persona-modal-overlay" class="hidden fixed inset-0 bg-black bg-opacity-60 z-40"></div>
    <div id="persona-modal" class="hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-11/12 max-w-2xl bg-white dark:bg-slate-800 rounded-2xl shadow-2xl z-50 flex flex-col transform scale-95 opacity-0">
        <div class="flex justify-between items-center p-4 border-b border-gray-200 dark:border-slate-700 flex-shrink-0">
            <h2 id="persona-modal-title" class="text-lg font-semibold text-gray-800 dark:text-gray-100">Tạo Chuyên gia AI của bạn</h2>
            <button id="close-persona-modal-btn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-slate-700">
                <svg class="w-6 h-6 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
            </button>
        </div>
        <div class="p-6 overflow-y-auto flex-1">
            <form id="persona-form" class="space-y-4">
                <input type="hidden" id="persona-id">
                <div>
                    <label for="persona-name" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Tên Persona</label>
                    <input type="text" id="persona-name" required class="block w-full px-3 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                </div>
                <div>
                    <label for="persona-icon" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Biểu tượng (Emoji)</label>
                    <input type="text" id="persona-icon" required maxlength="2" class="block w-full px-3 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                </div>
                <div>
                    <label for="persona-description" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Mô tả ngắn</label>
                    <textarea id="persona-description" rows="2" required class="block w-full px-3 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm resize-none"></textarea>
                </div>
                <div>
                    <div class="flex items-center justify-between">
                         <label for="persona-prompt" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Chỉ thị Hệ thống (System Prompt)</label>
                         <button type="button" id="generate-prompt-btn" class="p-1 rounded-full text-blue-600 dark:text-blue-400 hover:bg-blue-100 dark:hover:bg-slate-700" title="Gợi ý từ AI">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 3a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 0110 3zM3.05 4.29a.75.75 0 010 1.06l-1.06 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm12.84 1.06a.75.75 0 011.06 0l1.06 1.06a.75.75 0 11-1.06-1.06l-1.06-1.06a.75.75 0 010-1.06zM10 15a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 0110 15zM4.11 15.89a.75.75 0 011.06 0l1.06-1.06a.75.75 0 111.06 1.06l-1.06 1.06a.75.75 0 01-1.06 0l-1.06-1.06a.75.75 0 010-1.06zM15.89 15.89a.75.75 0 010 1.06l-1.06 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zM3 10a.75.75 0 01.75-.75h1.5a.75.75 0 010 1.5h-1.5A.75.75 0 013 10zM15 10a.75.75 0 01.75-.75h1.5a.75.75 0 010 1.5h-1.5A.75.75 0 0115 10zM10 6a4 4 0 100 8 4 4 0 000-8z" clip-rule="evenodd" /></svg>
                         </button>
                    </div>
                    <textarea id="persona-prompt" rows="6" required class="block w-full px-3 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm resize-y"></textarea>
                    <p class="mt-2 text-xs text-gray-500 dark:text-gray-400">Đây là chỉ dẫn cốt lõi cho AI, quyết định vai trò và phong cách của nó.</p>
                </div>
            </form>
        </div>
        <div class="flex justify-end items-center p-4 bg-gray-50 dark:bg-slate-900/50 border-t border-gray-200 dark:border-slate-700 flex-shrink-0 rounded-b-2xl">
            <button id="cancel-persona-btn" type="button" class="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-200 bg-white dark:bg-slate-700 border border-gray-300 dark:border-slate-600 rounded-md shadow-sm hover:bg-gray-50 dark:hover:bg-slate-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 mr-3">Hủy</button>
            <button id="save-persona-btn" type="submit" form="persona-form" class="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">Lưu Persona</button>
        </div>
    </div>

    <!-- Reference Modal -->
    <div id="reference-modal-overlay" class="hidden fixed inset-0 bg-black bg-opacity-50 z-40"></div>
    <div id="reference-modal" class="hidden fixed bottom-0 left-0 right-0 bg-white dark:bg-slate-800 rounded-t-2xl shadow-2xl z-50 flex flex-col transform transition-transform duration-300 ease-in-out" style="max-height: 85vh;">
        <div id="reference-header" class="flex justify-between items-center p-4 border-b border-gray-200 dark:border-slate-700 flex-shrink-0">
            <h2 id="reference-title" class="text-lg font-semibold text-gray-800 dark:text-gray-100">Trợ lý Phụ</h2>
            <button id="close-reference-modal-btn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-slate-700">
                <svg class="w-6 h-6 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
            </button>
        </div>
        <div id="reference-content" class="p-4 overflow-y-auto flex-1 space-y-4"></div>
        <div id="reference-input-area" class="p-4 bg-white dark:bg-slate-800 border-t border-gray-200 dark:border-slate-700 flex-shrink-0">
            <div class="flex items-center gap-3 bg-gray-100 dark:bg-slate-700 rounded-full p-2">
                <textarea id="reference-prompt-input" rows="1" placeholder="Hỏi trợ lý phụ..." class="flex-1 bg-transparent px-3 py-2 resize-none focus:outline-none dark:text-gray-200 dark:placeholder-gray-400"></textarea>
                <button id="reference-send-btn" class="w-10 h-10 flex items-center justify-center bg-blue-600 rounded-full text-white hover:bg-blue-700 transition-colors" title="Gửi">
                    <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2 .01 7z"/></svg>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Toast Notification Container -->
    <div id="toast-container" class="fixed top-5 right-5 z-[100] space-y-2"></div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";
        import { getAI, getGenerativeModel } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-ai.js";
        import { getFirestore, collection, doc, addDoc, updateDoc, getDoc, getDocs, deleteDoc, serverTimestamp, query, orderBy, limit, startAfter, where } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

        // Firebase config - Replace with your actual Firebase project configuration
        const firebaseConfig = {
             apiKey: "AIzaSyBDUBufnsk1PQZTLYCJDqASMX8hEVHqkDc",
             authDomain: "aimind-2362a.firebaseapp.com",
             projectId: "aimind-2362a",
             storageBucket: "aimind-2362a.firebasestorage.app",
             messagingSenderId: "377635504319",
             appId: "1:377635504319:web:7c6dd3cf0c52dd302d860a"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const ai = getAI(app);
        // Using gemini-2.5-flash for main and gemini-1.5-flash for faster, secondary tasks
        const model = getGenerativeModel(ai, { model: "gemini-2.5-flash" });
        const fastModel = getGenerativeModel(ai, { model: "gemini-1.5-flash" });

        // Global state variables
        let currentUserId = null;
        let currentUserName = '';
        let currentChatId = null;
        let chat; // Main chat session
        let localHistory = []; // Stores the full conversation history
        let isRecording = false;
        let referenceChat; // Reference chat session for the assistant modal
        let referenceHistory = [];
        let isSummarizing = false;
        let currentPersona = null; // Currently selected persona
        let customPersonas = []; // User-defined personas
        let activeSpeech = null; // Tracks current speech synthesis utterance
        let lastVisibleChat = null; // For infinite scrolling of chat history
        let isFetchingChats = false; // Flag to prevent multiple fetches
        let allChatsLoaded = false; // Flag to indicate all chats have been loaded
        const CHATS_PER_PAGE = 15; // Number of chats to load per page
        let isLearningMode = false; // State for learning mode

        // System prompt for learning mode. This is prepended to user prompts when learning mode is active.
        const LEARNING_MODE_SYSTEM_PROMPT = `**CHỈ THỊ HỆ THỐNG - CHẾ ĐỘ HỌC TẬP ĐANG BẬT**
Bạn là một người hướng dẫn học tập chuyên nghiệp. Khi người dùng yêu cầu một lộ trình học, hãy tuân thủ các quy tắc sau:
1.  **Tạo Lộ trình:** Trả lời bằng một danh sách có cấu trúc (dùng Markdown với gạch đầu dòng).
2.  **Tạo Liên kết Tương tác:** Đối với MỖI MỤC trong lộ trình, bạn PHẢI định dạng nó theo cú pháp đặc biệt sau: \`[Tên mục học]{"prompt":"Yêu cầu chi tiết để giải thích về mục học này"}\`
    * **[Tên mục học]**: Là tiêu đề của bài học. QUAN TRỌNG: Bên trong "Tên mục học", bạn không được sử dụng thêm dấu ngoặc vuông \`[]\` để nhấn mạnh bất kỳ thuật ngữ nào nào khác. Hãy viết tên mục một cách tự nhiên.
    * **{"prompt":"..."}**: Là một đối tượng JSON chứa một khóa "prompt". Giá trị của khóa này là một câu lệnh đầy đủ bạn tự tạo ra để yêu cầu chính bạn giải thích sâu về mục học đó. Prompt phải chi tiết và bằng tiếng Việt.
**Ví dụ yêu cầu từ người dùng:** "Tạo cho tôi lộ trình học Javascript."
**Ví dụ đầu ra MONG MUỐN từ bạn:**
* [Giới thiệu về Javascript và Lịch sử]{"prompt":"Hãy giải thích chi tiết Javascript là gì, lịch sử và vai trò của nó trong phát triển web hiện đại."}
* [Cú pháp cơ bản, Biến và Kiểu dữ liệu]{"prompt":"Trình bày bài học về cú pháp cơ bản của Javascript, cách khai báo biến với var, let, const, và các kiểu dữ liệu nguyên thủy như string, number, boolean, null, undefined."}`;


        // Element Selectors (Cached DOM elements for efficiency)
        const authContainer = document.getElementById('auth-container');
        const appContainer = document.getElementById('app-container');
        const loginView = document.getElementById('login-view');
        const registerView = document.getElementById('register-view');
        const loginForm = document.getElementById('login-form');
        const registerForm = document.getElementById('register-form');
        const googleLoginBtn = document.getElementById('google-login-btn');
        const showRegisterBtn = document.getElementById('show-register');
        const showLoginBtn = document.getElementById('show-login');
        const authError = document.getElementById('auth-error');
        const personaSelectionScreen = document.getElementById('persona-selection-screen');
        const welcomeUserName = document.getElementById('welcome-user-name');
        const createPersonaBtn = document.getElementById('create-persona-btn');
        const customPersonasSection = document.getElementById('custom-personas-section');
        const customPersonaGrid = document.getElementById('custom-persona-grid');
        const emptyCustomPersonaState = document.getElementById('empty-custom-persona-state');
        const defaultPersonaGrid = document.getElementById('default-persona-grid');
        const logoutBtnPersona = document.getElementById('logout-btn-persona');
        const chatViewContainer = document.getElementById('chat-view-container');
        const mainHeader = document.getElementById('main-header');
        const menuBtn = document.getElementById('menu-btn');
        const chatHeaderInfo = document.getElementById('chat-header-info');
        const newTopicBtn = document.getElementById('new-topic-btn');
        const summarizeBtn = document.getElementById('summarize-btn');
        const themeToggle = document.getElementById('theme-toggle');
        const themeToggleDarkIcon = document.getElementById('theme-toggle-dark-icon');
        const themeToggleLightIcon = document.getElementById('theme-toggle-light-icon');
        const logoutBtn = document.getElementById('logout-btn');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const sidebar = document.getElementById('sidebar');
        const closeSidebarBtn = document.getElementById('close-sidebar-btn');
        const sidebarContent = document.getElementById('sidebar-content');
        const newChatBtn = document.getElementById('new-chat-btn');
        const pinnedChatsSection = document.getElementById('pinned-chats-section');
        const pinnedChatsList = document.getElementById('pinned-chats-list');
        const savedChatsList = document.getElementById('saved-chats-list');
        const savedChatsSkeleton = document.getElementById('saved-chats-skeleton');
        const mainContent = document.getElementById('main-content');
        const welcomeScreen = document.getElementById('welcome-screen');
        const chatContainer = document.getElementById('chat-container');
        const notificationArea = document.getElementById('notification-area');
        const suggestionArea = document.getElementById('suggestion-area');
        const toggleSuggestionsBtn = document.getElementById('toggle-suggestions-btn');
        const suggestionsContainer = document.getElementById('suggestions-container');
        const inputAreaWrapper = document.getElementById('input-area-wrapper');
        const inputArea = document.getElementById('input-area');
        const referenceBtn = document.getElementById('reference-btn');
        const promptInput = document.getElementById('prompt-input');
        const recordBtn = document.getElementById('record-btn');
        const sendBtn = document.getElementById('send-btn');
        const personaModalOverlay = document.getElementById('persona-modal-overlay');
        const personaModal = document.getElementById('persona-modal');
        const personaModalTitle = document.getElementById('persona-modal-title');
        const closePersonaModalBtn = document.getElementById('close-persona-modal-btn');
        const personaForm = document.getElementById('persona-form');
        const personaIdInput = document.getElementById('persona-id');
        const personaNameInput = document.getElementById('persona-name');
        const personaIconInput = document.getElementById('persona-icon');
        const personaDescriptionInput = document.getElementById('persona-description');
        const personaPromptInput = document.getElementById('persona-prompt');
        const generatePromptBtn = document.getElementById('generate-prompt-btn');
        const cancelPersonaBtn = document.getElementById('cancel-persona-btn');
        const savePersonaBtn = document.getElementById('save-persona-btn');
        const referenceModalOverlay = document.getElementById('reference-modal-overlay');
        const referenceModal = document.getElementById('reference-modal');
        const referenceHeader = document.getElementById('reference-header');
        const referenceTitle = document.getElementById('reference-title');
        const closeReferenceModalBtn = document.getElementById('close-reference-modal-btn');
        const referenceContent = document.getElementById('reference-content');
        const referenceInputArea = document.getElementById('reference-input-area');
        const referencePromptInput = document.getElementById('reference-prompt-input');
        const referenceSendBtn = document.getElementById('reference-send-btn');
        const learningModeToggle = document.getElementById('learning-mode-toggle'); 
        const learningModeIndicator = document.getElementById('learning-mode-indicator');
        const chatScrollContainer = document.getElementById("chat-container"); // Re-caching for clarity
        const scrollToTopBtn = document.getElementById("scrollToTopBtn"); // Re-caching for clarity

        // Pre-defined default personas
        const defaultPersonas = [
            { id: 'general', name: 'Trợ lý Toàn năng', icon: '🧠', description: 'Kiến thức tổng quát, trả lời đa dạng các chủ đề.', systemPrompt: `**Chỉ thị hệ thống:** Mục tiêu chính của bạn là đưa ra câu trả lời rõ ràng, chi tiết và có cấu trúc tốt. Luôn sử dụng Markdown để định dạng (tiêu đề, danh sách, in đậm). Hãy giải thích các khái niệm từng bước, bắt đầu bằng tóm tắt rồi đi vào chi tiết và ví dụ. **Yêu cầu bổ sung:** Trong quá trình trả lời, khi bạn đề cập đến một thuật ngữ kỹ thuật, một khái niệm quan trọng, hoặc một tên riêng (ví dụ: tên một công nghệ, một phương pháp), hãy bọc thuật ngữ đó trong cặp dấu ngoặc vuông. Ví dụ: '...sử dụng ngôn ngữ [JavaScript] để tương tác với [DOM]...'. Chỉ bọc duy nhất thuật ngữ đó.` },
            { id: 'programmer', name: 'Chuyên gia Lập trình', icon: '👨‍💻', description: 'Chuyên gia về mã nguồn, thuật toán, gỡ lỗi code.', systemPrompt: `**Chỉ thị hệ thống:** Bạn là một lập trình viên cao cấp với 10 năm kinh nghiệm. Luôn đưa ra câu trả lời dưới dạng mã nguồn được giải thích rõ ràng, tuân thủ các coding convention tốt nhất. Khi được yêu cầu, hãy phân tích ưu và nhược điểm của các giải pháp khác nhau. Hãy ưu tiên tính hiệu quả và khả năng bảo trì của mã nguồn. **Yêu cầu bổ sung:** Khi đề cập đến một hàm, thư viện, hoặc khái niệm lập trình, hãy bọc nó trong dấu ngoặc vuông, ví dụ: [React], [API], [useState].` },
            { id: 'writer', name: 'Nhà văn Sáng tạo', icon: '✍️', description: 'Hỗ trợ viết lách, lên ý tưởng, xây dựng cốt truyện.', systemPrompt: `**Chỉ thị hệ thống:** Bạn là một nhà văn và biên tập viên chuyên nghiệp. Phong cách của bạn giàu cảm xúc, sử dụng từ ngữ phong phú và hình ảnh. Hãy giúp người dùng lên ý tưởng, phát triển nhân vật, xây dựng cốt truyện, hoặc viết các đoạn văn, bài thơ theo yêu cầu. Luôn giữ một giọng văn truyền cảm hứng.` },
            { id: 'marketing', name: 'Chuyên gia Marketing', icon: '📈', description: 'Tư vấn chiến lược, phân tích thị trường, quảng cáo.', systemPrompt: `**Chỉ thị hệ thống:** Bạn là một giám đốc marketing dày dặn kinh nghiệm. Hãy cung cấp các phân tích thị trường sắc bén, đề xuất các chiến lược marketing marketing sáng tạo, và giúp viết các nội dung quảng cáo (copywriting) hấp dẫn, tập trung vào lợi ích của khách hàng và lời kêu gọi hành động (CTA) rõ ràng.` }
        ];

        // --- UTILITY FUNCTIONS ---
        /**
         * Displays a toast notification message to the user.
         * @param {string} message - The message to display.
         * @param {'info'|'success'|'error'} type - The type of toast (determines color and icon).
         */
        function showToast(message, type = 'info') {
            const toastContainer = document.getElementById('toast-container');
            if (!toastContainer) return;
            const toast = document.createElement('div');
            
            let bgColor, textColor, icon;

            switch (type) {
                case 'success':
                    bgColor = 'bg-green-100 dark:bg-green-900';
                    textColor = 'text-green-700 dark:text-green-200';
                    icon = `<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>`;
                    break;
                case 'error':
                    bgColor = 'bg-red-100 dark:bg-red-900';
                    textColor = 'text-red-700 dark:text-red-200';
                    icon = `<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>`;
                    break;
                default: // info
                    bgColor = 'bg-blue-100 dark:bg-blue-900';
                    textColor = 'text-blue-700 dark:text-blue-200';
                    icon = `<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>`;
                    break;
            }

            toast.className = `toast max-w-xs w-full ${bgColor} ${textColor} p-4 rounded-lg shadow-lg flex items-center space-x-3`;
            toast.innerHTML = `
                <div class="flex-shrink-0">${icon}</div>
                <div class="flex-1 text-sm font-medium">${message}</div>
            `;

            toastContainer.appendChild(toast);
            
            // Trigger reflow to enable CSS transition
            requestAnimationFrame(() => {
                toast.classList.add('show');
            });

            const hideToast = () => {
                toast.classList.remove('show');
                toast.classList.add('hide');
                toast.addEventListener('transitionend', () => {
                    if (toast.parentNode) {
                        toast.remove();
                    }
                }, { once: true });
            };

            toast.addEventListener('click', hideToast); // Allow dismissing by clicking
            setTimeout(hideToast, 4000); // Auto-hide after 4 seconds
        }
        
        /**
         * Copies text to the clipboard.
         * @param {string} text - The text to copy.
         */
        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'absolute';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showToast('Đã sao chép vào bộ nhớ đệm!', 'success');
            } catch (err) {
                showToast('Không thể sao chép.', 'error');
            }
            document.body.removeChild(textarea);
        }

        // --- AUTHENTICATION ---
        // Listens for Firebase authentication state changes
        onAuthStateChanged(auth, async user => {
            if (user) {
                currentUserId = user.uid;
                const email = user.email || '';
                // Use user display name or derive from email
                currentUserName = user.displayName || email.split('@')[0]; 
                welcomeUserName.textContent = currentUserName;
                
                // Show app UI and hide auth UI
                authContainer.classList.add('hidden');
                appContainer.classList.remove('hidden');

                // Load personas and chats
                await showPersonaSelectionScreen();
                await renderAllChats(); // Initial render of chat list
            } else {
                // User is signed out, reset state and show auth UI
                currentUserId = null;
                currentUserName = '';
                authContainer.classList.remove('hidden');
                appContainer.classList.add('hidden');
                chatViewContainer.classList.add('hidden');
                personaSelectionScreen.classList.add('hidden');
            }
        });

        // Event listeners for authentication forms and buttons
        loginForm.addEventListener('submit', async e => { 
            e.preventDefault(); 
            try { 
                await signInWithEmailAndPassword(auth, loginForm['login-email'].value, loginForm['login-password'].value); 
                authError.textContent = ''; 
            } catch (error) { 
                authError.textContent = "Email hoặc mật khẩu không đúng."; 
                showToast('Email hoặc mật khẩu không đúng.', 'error'); 
            } 
        });
        registerForm.addEventListener('submit', async e => { 
            e.preventDefault(); 
            try { 
                await createUserWithEmailAndPassword(auth, registerForm['register-email'].value, registerForm['register-password'].value); 
                authError.textContent = ''; 
            } catch (error) { 
                authError.textContent = "Không thể tạo tài khoản. Vui lòng thử lại."; 
                showToast('Không thể tạo tài khoản. Vui lòng thử lại.', 'error'); 
            } 
        });
        googleLoginBtn.addEventListener('click', async () => { 
            try { 
                await signInWithPopup(auth, new GoogleAuthProvider()); 
                authError.textContent = ''; 
            } catch (error) { 
                authError.textContent = "Đăng nhập Google thất bại."; 
                showToast('Đăng nhập Google thất bại.', 'error');
            } 
        });
        const handleSignOut = () => signOut(auth);
        logoutBtn.addEventListener('click', handleSignOut);
        logoutBtnPersona.addEventListener('click', handleSignOut);
        showRegisterBtn.addEventListener('click', () => { 
            loginView.classList.add('hidden'); 
            registerView.classList.remove('hidden'); 
            authError.textContent = ''; 
        });
        showLoginBtn.addEventListener('click', () => { 
            registerView.classList.add('hidden'); 
            loginView.classList.remove('hidden'); 
            authError.textContent = ''; 
        });

        // --- THEME ---
        /** Updates the theme toggle icon based on the current theme. */
        const updateThemeIcon = () => {
            if (document.documentElement.classList.contains('dark')) {
                themeToggleDarkIcon.classList.add('hidden');
                themeToggleLightIcon.classList.remove('hidden');
            } else {
                themeToggleDarkIcon.classList.remove('hidden');
                themeToggleLightIcon.classList.add('hidden');
            }
        };
        themeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            localStorage.setItem('color-theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
            updateThemeIcon();
        });
        updateThemeIcon(); // Initial call to set the correct icon on load
        
        // --- PERSONA SELECTION ---
        /** Shows the persona selection screen and refreshes persona lists. */
        async function showPersonaSelectionScreen() {
            clearSuggestions(); // Clear any existing suggestions

            welcomeScreen.classList.add('hidden');
            welcomeScreen.classList.remove('flex'); // Ensure welcome screen is hidden
            personaSelectionScreen.classList.remove('hidden'); // Show persona selection
            chatViewContainer.classList.add('hidden'); // Hide chat view

            await fetchCustomPersonas(); // Fetch user-created personas
            renderDefaultPersonas(); // Render static default personas
            renderCustomPersonas(); // Render fetched custom personas
            
            if(speechSynthesis.speaking) speechSynthesis.cancel(); // Stop any ongoing speech
            closeSidebar(); // Ensure sidebar is closed

            // If a persona was previously selected, generate welcome suggestions for it
            if (currentPersona) {
                await generateWelcomeSuggestions();
            } else {
                // If no persona selected yet, ensure welcome suggestions are cleared or default message shown
                document.getElementById('welcome-suggestions-container').innerHTML = '';
            }
        }

        /** Renders the default personas to the grid. */
        function renderDefaultPersonas() {
            defaultPersonaGrid.innerHTML = '';
            defaultPersonas.forEach(persona => {
                const card = createPersonaCard(persona, false);
                // When a default persona is clicked, start a new chat with it
                card.onclick = () => startNewChat(persona.id);
                defaultPersonaGrid.appendChild(card);
            });
        }
        
        /** Renders the custom personas to the grid, showing empty state if none exist. */
        function renderCustomPersonas() {
            customPersonaGrid.innerHTML = '';
            if (customPersonas.length > 0) {
                customPersonaGrid.classList.remove('hidden');
                emptyCustomPersonaState.classList.add('hidden');
                customPersonas.forEach(persona => {
                    const card = createPersonaCard(persona, true);
                    // For custom personas, also indicate if it's custom when starting chat
                    card.onclick = () => startNewChat(persona.id, true);
                    customPersonaGrid.appendChild(card);
                });
            } else {
                customPersonaGrid.classList.add('hidden');
                emptyCustomPersonaState.classList.remove('hidden');
            }
        }
        
        /**
         * Creates an HTML card element for a given persona.
         * @param {object} persona - The persona data.
         * @param {boolean} isCustom - True if it's a custom persona, to add edit/delete buttons.
         * @returns {HTMLElement} The created persona card element.
         */
        function createPersonaCard(persona, isCustom) {
            const card = document.createElement('div');
            card.className = 'persona-card cursor-pointer p-4 sm:p-5 bg-white dark:bg-slate-800 rounded-2xl shadow-md flex flex-col items-center text-center h-full';
            card.innerHTML = `
                <div class="text-4xl sm:text-5xl mb-3 sm:mb-4">${persona.icon}</div>
                <h3 class="text-base sm:text-lg font-bold text-gray-800 dark:text-gray-100 mb-2">${persona.name}</h3>
                <p class="text-xs sm:text-sm text-gray-600 dark:text-gray-400 flex-1">${persona.description}</p>
            `;
            if (isCustom) {
                const actionsWrapper = document.createElement('div');
                actionsWrapper.className = 'custom-persona-actions flex items-center gap-1';
                actionsWrapper.innerHTML = `
                    <button class="edit-persona-btn p-1.5 bg-white/50 dark:bg-slate-900/50 backdrop-blur-sm rounded-full text-gray-600 dark:text-gray-300 hover:text-blue-500 dark:hover:text-blue-400" title="Chỉnh sửa"><svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z"></path><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd"></path></svg></button>
                    <button class="delete-persona-btn p-1.5 bg-white/50 dark:bg-slate-900/50 backdrop-blur-sm rounded-full text-gray-600 dark:text-gray-300 hover:text-red-500 dark:hover:text-red-400" title="Xóa"><svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg></button>
                `;
                actionsWrapper.querySelector('.edit-persona-btn').onclick = (e) => { e.stopPropagation(); openPersonaModal(persona); };
                actionsWrapper.querySelector('.delete-persona-btn').onclick = (e) => { e.stopPropagation(); deletePersona(persona.id, persona.name); };
                card.appendChild(actionsWrapper);
            }
            return card;
        }

        // --- PERSONA MODAL ---
        /**
         * Opens the persona creation/edit modal.
         * @param {object} [personaToEdit=null] - Optional persona object to pre-fill the form for editing.
         */
        function openPersonaModal(personaToEdit = null) {
            personaForm.reset(); // Clear form fields
            if (personaToEdit) {
                personaModalTitle.textContent = 'Chỉnh sửa Persona';
                personaIdInput.value = personaToEdit.id;
                personaNameInput.value = personaToEdit.name;
                personaIconInput.value = personaToEdit.icon;
                personaDescriptionInput.value = personaToEdit.description;
                personaPromptInput.value = personaToEdit.systemPrompt;
            } else {
                personaModalTitle.textContent = 'Tạo Chuyên gia AI của bạn';
                personaIdInput.value = ''; // Clear ID for new persona
            }
            personaModalOverlay.classList.remove('hidden');
            personaModal.classList.remove('hidden');
            // Animate modal entry
            requestAnimationFrame(() => {
                personaModal.classList.remove('scale-95', 'opacity-0');
            });
        }

        /** Closes the persona creation/edit modal with animation. */
        function closePersonaModal() {
            personaModal.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                personaModalOverlay.classList.add('hidden');
                personaModal.classList.add('hidden');
            }, 300); // Match CSS transition duration
        }

        // --- PERSONA CRUD ---
        /** Fetches custom personas for the current user from Firestore. */
        async function fetchCustomPersonas() {
            if (!currentUserId) return;
            const personasCol = collection(db, 'users', currentUserId, 'customPersonas');
            const q = query(personasCol, orderBy('createdAt', 'desc')); // Order by creation time
            const snapshot = await getDocs(q);
            customPersonas = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        }

        /**
         * Handles saving a new or updated persona to Firestore.
         * @param {Event} e - The form submission event.
         */
        async function handleSavePersona(e) {
            e.preventDefault();
            if (!currentUserId) return;

            const personaData = {
                name: personaNameInput.value.trim(),
                icon: personaIconInput.value.trim() || '🤖', // Default icon if none provided
                description: personaDescriptionInput.value.trim(),
                systemPrompt: personaPromptInput.value.trim(),
                ownerId: currentUserId // Link persona to the creating user
            };

            const personaId = personaIdInput.value;
            savePersonaBtn.disabled = true; // Disable button to prevent double submission
            try {
                if (personaId) { // Update existing persona
                    const docRef = doc(db, 'users', currentUserId, 'customPersonas', personaId);
                    await updateDoc(docRef, personaData);
                } else { // Create new persona
                    personaData.createdAt = serverTimestamp(); // Add timestamp for ordering
                    const collectionRef = collection(db, 'users', currentUserId, 'customPersonas');
                    await addDoc(collectionRef, personaData);
                }
                closePersonaModal();
                showToast('Persona đã được lưu thành công!', 'success');
                await showPersonaSelectionScreen(); // Refresh the persona list after saving
            } catch (error) {
                console.error("Lỗi khi lưu persona:", error);
                showToast('Lỗi khi lưu persona.', 'error');
            } finally {
                savePersonaBtn.disabled = false; // Re-enable button
            }
        }
        
        /**
         * Deletes a custom persona from Firestore.
         * @param {string} personaId - The ID of the persona to delete.
         * @param {string} personaName - The name of the persona (for confirmation message).
         */
        async function deletePersona(personaId, personaName) {
            if (!confirm(`Bạn có chắc chắn muốn xóa persona "${personaName}" không? Hành động này không thể hoàn tác.`)) return;

            try {
                await deleteDoc(doc(db, 'users', currentUserId, 'customPersonas', personaId));
                showToast(`Persona "${personaName}" đã được xóa.`, 'success');
                await showPersonaSelectionScreen(); // Refresh the persona list after deletion
            } catch (error) {
                console.error("Lỗi khi xóa persona:", error);
                showToast('Lỗi khi xóa persona.', 'error');
            }
        }
        
        // --- CHAT LOGIC ---

        /**
         * Pre-processes the text from the AI response to create interactive links
         * for learning mode and term explanations.
         * @param {string} text - The raw text from the AI response.
         * @returns {string} The HTML string with interactive links.
         */
        function preprocessText(text) {
            const learningLinkRegex = /\[([^\]]+?)\]\{"prompt":"([^"]+?)"\}/g;
            const termLinkRegex = /\[([^\]]+?)\]/g;
            
            const parts = [];
            let lastIndex = 0;
            let match;

            // Step 1: Find all learning links and replace them first
            // This prioritizes learning links over term links to prevent double-processing
            while ((match = learningLinkRegex.exec(text)) !== null) {
                // Add the text before this match
                parts.push(text.substring(lastIndex, match.index));
                
                const title = match[1];
                const prompt = match[2];

                // Create the learning link HTML. The title itself is NOT processed for term links.
                // Sanitize prompt for use in data-attribute
                const sanitizedPrompt = prompt.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                parts.push(`<a href="#" class="learning-link" data-prompt="${sanitizedPrompt}">${title}</a>`);
                
                lastIndex = match.index + match[0].length;
            }

            // Add the remaining text after the last match
            parts.push(text.substring(lastIndex));

            // Step 2: Process the parts that are NOT learning links for term links.
            const finalParts = parts.map(part => {
                // Check if the part is already a generated HTML tag (a learning link)
                if (part.startsWith('<a href="#" class="learning-link"')) {
                    return part; // This is a learning link, don't process it further
                } else {
                    // This is regular text, process it for term links
                    return part.replace(termLinkRegex, `<a href="#" class="term-link" data-term="$1">$1</a>`);
                }
            });

            return finalParts.join('');
        }


        /**
         * Starts a new chat session with a selected persona.
         * @param {string} personaId - The ID of the persona.
         * @param {boolean} [isCustom=false] - Whether the persona is custom or default.
         */
        async function startNewChat(personaId, isCustom = false) {
            let selectedPersona;
            if (isCustom) {
                selectedPersona = customPersonas.find(p => p.id === personaId);
            } else {
                selectedPersona = defaultPersonas.find(p => p.id === personaId);
            }

            if (!selectedPersona) { 
                showToast('Không tìm thấy Persona.', 'error');
                return; 
            }
            
            clearSuggestions(); // Clear existing suggestions
            currentPersona = selectedPersona; // Set the current persona
            
            // Show chat view and hide persona selection
            personaSelectionScreen.classList.add('hidden');
            chatViewContainer.classList.remove('hidden');
            chatViewContainer.classList.add('flex'); // Ensure flex display

            updateChatHeader(currentPersona); // Update header with persona info
            updateLearningModeIndicator(); // Update learning mode indicator in header
            
            // Reset chat state for a new conversation
            currentChatId = null;
            chat = null; // Clear main chat session
            localHistory = [{
                role: "user",
                parts: [{ text: currentPersona.systemPrompt }], // Initial system prompt
            }, {
                role: "model",
                parts: [{ text: "Đã hiểu! Tôi đã sẵn sàng. Bạn cần tôi giúp gì?" }], // Initial AI greeting
            }];
            
            // Clear chat display and add notification area
            chatContainer.innerHTML = '';
            chatContainer.appendChild(notificationArea);
            
            await renderAllChats(); // Re-render sidebar chat list
            closeSidebar(); // Close sidebar
            if(speechSynthesis.speaking) speechSynthesis.cancel(); // Stop any speech
            
            await generateWelcomeSuggestions(); // Generate welcome suggestions for the new chat
        }
        
        /**
         * Updates the chat header with the current persona's information.
         * @param {object} persona - The current persona object.
         */
        function updateChatHeader(persona) {
            if(persona) {
                chatHeaderInfo.innerHTML = `
                    <span class="text-2xl">${persona.icon}</span>
                    <span class="text-lg font-bold text-gray-800 dark:text-gray-100">${persona.name}</span>
                    <!-- Learning Mode Indicator is dynamically managed by updateLearningModeIndicator -->
                `;
                updateLearningModeIndicator(); // Ensure indicator state is correct
            } else {
                chatHeaderInfo.innerHTML = ''; // Clear header if no persona is selected
            }
        }
        
        /**
         * Adds action buttons (copy, speak) to a message.
         * @param {HTMLElement} actionsContainer - The container for the action buttons.
         * @param {string} rawText - The raw text content of the message.
         */
        function addMessageActions(actionsContainer, rawText) {
             // Only add actions if container exists and text is not empty or a blinking cursor
             if (!actionsContainer || !rawText || rawText.includes('blinking-cursor')) return;
            
            actionsContainer.innerHTML = ''; // Clear previous actions

            // Copy button
            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn p-1.5 text-gray-500 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded-full transition-colors';
            copyBtn.innerHTML = `<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 00-3.375-3.375h-1.5a1.125 1.125 0 01-1.125-1.125v-1.5a3.375 3.375 0 00-3.375-3.375H9.75" /></svg>`;
            copyBtn.title = 'Sao chép nội dung';
            copyBtn.dataset.text = rawText; // Store raw text for copying
            actionsContainer.appendChild(copyBtn);
            
            // Speak button
            const speakBtn = document.createElement('button');
            speakBtn.className = 'speak-btn p-1.5 text-gray-500 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded-full transition-colors';
            speakBtn.innerHTML = '🔊';
            speakBtn.title = 'Đọc văn bản';
            speakBtn.dataset.text = rawText; // Store raw text for speech
            speakBtn.dataset.state = 'idle'; // Initial state for speech
            actionsContainer.appendChild(speakBtn);
        }

        /**
         * Adds a message to the chat display.
         * @param {'user'|'ai'|'model'|'note'|'summary'} role - The role of the message sender.
         * @param {string} text - The content of the message.
         * @param {boolean} [shouldScroll=true] - Whether to scroll the chat to the bottom after adding the message.
         * @returns {{messageWrapper: HTMLElement, contentElem: HTMLElement, statusElem?: HTMLElement, actionsContainer?: HTMLElement}}
         * References to the created message elements.
         */
        function addMessage(role, text, shouldScroll = true) {
            const messageWrapper = document.createElement('div');
            let contentElem;
            let statusElem;
            let actionsContainer = null; // Initialize actionsContainer

            if (role === 'ai' || role === 'model') {
                messageWrapper.className = 'w-full space-y-2';
                messageWrapper.innerHTML = `
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-2">
                            <div class="w-7 h-7 rounded-full flex-shrink-0 bg-gradient-to-tr from-purple-400 to-indigo-500 flex items-center justify-center">
                               <svg class="w-4 h-4 text-white" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M12 6c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6 2.69-6 6-6m0-2c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8z"/><path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
                            </div>
                            <span class="font-semibold text-gray-800 dark:text-gray-200">${currentPersona?.name || 'Gemini'}</span>
                        </div>
                        <div class="ai-status"></div>
                    </div>
                    <div class="message-content text-gray-800 dark:text-gray-200" data-raw-text="${text.replace(/"/g, '&quot;')}"></div>
                    <div class="message-actions mt-1 flex justify-end items-center gap-2"></div>`;
                contentElem = messageWrapper.querySelector('.message-content');
                statusElem = messageWrapper.querySelector('.ai-status');
                actionsContainer = messageWrapper.querySelector('.message-actions');
            } else if (role === 'user') {
                messageWrapper.className = 'flex justify-end';
                messageWrapper.innerHTML = `<div class="message-content px-4 py-2 rounded-2xl bg-blue-600 dark:bg-blue-700 text-white max-w-xs sm:max-w-md lg:max-w-2xl"></div>`;
                contentElem = messageWrapper.querySelector('.message-content');
            } else if (role === 'note') {
                messageWrapper.className = 'note-wrapper';
                messageWrapper.innerHTML = `
                    <div class="note-header">
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M5.433 13.917l1.262-3.155A4 0 017.58 9.42l6.92-6.918a2.121 2.121 0 013 3l-6.92 6.918c-.383.383-.84.685-1.343.886l-3.154 1.262a.5.5 0 01-.65-.65z" /><path d="M3.5 5.75c0-.69.56-1.25 1.25-1.25H10A.75.75 0 0010 3H4.75A2.75 2.75 0 002 5.75v9.5A2.75 2.75 0 004.75 18h9.5A2.75 2.75 0 0017 15.25V10a.75.75 0 00-1.5 0v5.25c0 .69-.56 1.25-1.25 1.25h-9.5c-.69 0-1.25-.56-1.25-1.25v-9.5z" /></svg>
                        <span>Ghi chú</span>
                    </div>
                    <div class="note-content message-content" data-raw-text="${text.replace(/"/g, '&quot;')}"></div>
                `;
                contentElem = messageWrapper.querySelector('.note-content');
            } else if (role === 'summary') {
                messageWrapper.className = 'summary-wrapper';
                messageWrapper.innerHTML = `
                    <div class="summary-header">
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M2 4.75A.75.75 0 012.75 4h14.5a.75.75 0 010 1.5H2.75A.75.75 0 012 4.75zM2 10a.75.75 0 01.75-.75h14.5a.75.75 0 010 1.5H2.75A.75.75 0 012 10zm0 5.25a.75.75 0 01.75-.75h9.5a.75.75 0 010 1.5h-9.5a.75.75 0 01-.75-.75z" clip-rule="evenodd" /></svg>
                        <span>Tóm tắt cuộc trò chuyện</span>
                    </div>
                    <div class="summary-content message-content" data-raw-text="${text.replace(/"/g, '&quot;')}"></div>
                    <div class="message-actions mt-1 flex justify-end items-center gap-2"></div>
                `;
                contentElem = messageWrapper.querySelector('.summary-content');
                actionsContainer = messageWrapper.querySelector('.message-actions');
            }
            
            // Process text for interactive links and sanitize before rendering Markdown
            const preprocessedText = preprocessText(text);
            contentElem.innerHTML = DOMPurify.sanitize(marked.parse(preprocessedText), { ADD_ATTR: ['target', 'data-term', 'data-prompt'] });

            // Only add message actions if actionsContainer is not null (i.e., for AI/model messages or summaries)
            if (actionsContainer) {
                addMessageActions(actionsContainer, text);
            }

            // Insert message into chat container before the notification area
            chatContainer.insertBefore(messageWrapper, notificationArea);
            if (shouldScroll) {
                // Scroll the chatContainer itself to the bottom
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }

            return { messageWrapper, contentElem, statusElem, actionsContainer }; // Return elements for further manipulation
        }
        
        /** Summarizes the current conversation history. */
        async function handleSummary() {
            if (isSummarizing) return;
            
            // Filter out 'note' and 'summary' messages and format for the summary prompt
            const conversationToSummarize = localHistory
                .filter(msg => ['user', 'model'].includes(msg.role))
                .map(msg => `${msg.role === 'user' ? 'User' : 'AI'}: ${msg.parts[0].text}`)
                .join('\n\n');

            // Prevent summarizing very short conversations
            if (conversationToSummarize.length < 100) { 
                showToast('Chưa có đủ nội dung để tóm tắt.', 'info');
                return;
            }

            isSummarizing = true;
            const originalIcon = summarizeBtn.innerHTML;
            summarizeBtn.innerHTML = `<svg class="w-6 h-6 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
            summarizeBtn.disabled = true;

            try {
                const prompt = `Dựa vào cuộc trò chuyện sau, hãy tóm tắt lại các ý chính một cách súc tích, rõ ràng theo từng gạch đầu dòng:\n\n---\n${conversationToSummarize}\n---`;
                const result = await fastModel.generateContent(prompt);
                const summaryText = result.response.text();

                addMessage('summary', summaryText); // Display the summary in chat
                
                // Add summary to local history and update in DB
                localHistory.push({ role: 'summary', parts: [{ text: summaryText }] });
                await updateConversationInDb();

            } catch (error) {
                console.error("Lỗi khi tóm tắt:", error);
                showToast('Không thể tạo bản tóm tắt lúc này.', 'error');
            } finally {
                isSummarizing = false;
                summarizeBtn.innerHTML = originalIcon; // Restore button icon
                summarizeBtn.disabled = false;
            }
        }

        /**
         * Sends a message to the AI model and displays the response.
         * @param {string} [promptTextOverride=null] - Optional text to use as the user's prompt, overriding the input field.
         * Used for learning links where the display text might differ from the prompt sent to AI.
         */
        async function sendMessage(promptTextOverride = null) {
            console.log("--- sendMessage called ---");
            console.log("Initial localHistory length:", localHistory.length);

            // Ensure chat view is visible
            welcomeScreen.classList.add('hidden');
            welcomeScreen.classList.remove('flex');
            chatContainer.classList.remove('hidden');
        
            // Determine the text to display for the user's message and the actual prompt to send
            const userDisplayedText = promptTextOverride ? promptTextOverride : promptInput.value.trim(); 
            const actualPromptToSend = promptTextOverride || promptInput.value.trim();

            if (!actualPromptToSend || isSummarizing) return; // Prevent sending empty messages or during summarization

            // If this is a direct user message from input, clear the input
            if (!promptTextOverride) {
                promptInput.value = '';
                adjustInputHeight();
            }

            sendBtn.disabled = true; // Disable send button
            clearSuggestions(); // Always clear suggestions before AI responds

            // Display what the user *sees* as their message.
            addMessage('user', userDisplayedText);
            localHistory.push({ role: 'user', parts: [{ text: userDisplayedText }] });
            console.log("localHistory after adding user message:", JSON.parse(JSON.stringify(localHistory)));
        
            // Add a placeholder message for AI response with a blinking cursor
            const { messageWrapper, contentElem, statusElem, actionsContainer } = addMessage('ai', '<span class="blinking-cursor"></span>');
            if (statusElem) statusElem.textContent = 'Đang suy nghĩ...';

            try {
                let historyForThisCall = [];
                // Iterate over localHistory up to the current user's prompt (which is the last 'user' message)
                // to build a valid chat history for the AI model.
                const historyLength = localHistory.length;
                for (let i = 0; i < historyLength; i++) {
                    const message = localHistory[i];

                    // Skip 'note' and 'summary' roles as they are not part of the AI conversation history
                    if (message.role === 'note' || message.role === 'summary') {
                        continue;
                    }

                    // If this is the current user's message (the last 'user' message in localHistory),
                    // it will be passed as the 'prompt' argument to sendMessageStream, not as part of history.
                    // So we break before adding the very last user message.
                    if (i === historyLength - 1 && message.role === 'user') {
                        break; 
                    }
                    
                    // Enforce strict alternation for user and model roles for the API call.
                    // This is crucial for models that require an alternating history.
                    if (historyForThisCall.length > 0 && historyForThisCall[historyForThisCall.length - 1].role === message.role) {
                        if (message.role === 'model') {
                            console.warn("Skipping consecutive 'model' message found in localHistory during history preparation:", message);
                            // If a model message follows another model message, skip it.
                            // This effectively "heals" the history for the API call.
                            continue;
                        }
                    }

                    historyForThisCall.push(message);
                }

                // Apply learning mode prompt if active and it's a new user prompt (not from clicking a learning link)
                let finalPrompt;
                // If promptTextOverride is used, it means a learning link was clicked, so no need to wrap with learning mode prompt.
                if (isLearningMode && !promptTextOverride) { 
                    finalPrompt = `${LEARNING_MODE_SYSTEM_PROMPT}\n\nYêu cầu của người học: "${actualPromptToSend}"`;
                } else {
                    finalPrompt = actualPromptToSend;
                }

                console.log("History sent to startChat:", JSON.parse(JSON.stringify(historyForThisCall))); 
                const chatSession = model.startChat({ history: historyForThisCall });
                const result = await chatSession.sendMessageStream(finalPrompt);

                let fullResponseText = "";
                let isFirstChunk = true;
        
                // Stream response chunks
                for await (const chunk of result.stream) {
                    if (isFirstChunk) {
                        if (statusElem) statusElem.textContent = 'Đang viết...';
                        isFirstChunk = false;
                    }
                    fullResponseText += chunk.text();
                    
                    // Update content with blinking cursor until stream ends
                    const processedChunk = preprocessText(fullResponseText + '<span class="blinking-cursor"></span>');
                    contentElem.innerHTML = DOMPurify.sanitize(marked.parse(processedChunk), {ADD_ATTR: ['target', 'data-term', 'data-prompt']});
                    // Scroll to bottom as new content arrives
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                }
                
                if (statusElem) statusElem.classList.add('hidden'); // Hide status when done
                
                // Final render without blinking cursor and store raw text for actions
                const finalProcessedText = preprocessText(fullResponseText);
                contentElem.innerHTML = DOMPurify.sanitize(marked.parse(finalProcessedText), {ADD_ATTR: ['target', 'data-term', 'data-prompt']});
                contentElem.dataset.rawText = fullResponseText;
                
                addMessageActions(actionsContainer, fullResponseText); // Add copy/speak buttons
                
                // Scroll to the start of the message after a small delay for smoother effect
                setTimeout(() => {
                     messageWrapper.scrollIntoView({ behavior: "smooth", block: "start" });
                }, 100);
        
                localHistory.push({ role: 'model', parts: [{ text: fullResponseText }] });
                console.log("localHistory after adding model message:", JSON.parse(JSON.stringify(localHistory)));
                await updateConversationInDb(); // Save updated conversation to DB
                
                // Only get follow-up suggestions if NOT in learning mode.
                // In learning mode, structured links are the "suggestions".
                if (!isLearningMode) {
                    await getFollowUpSuggestions(fullResponseText);
                } else {
                    clearSuggestions(); // Ensure suggestions are cleared if learning mode is on
                }

            } catch (error) {
                console.error("Error during sendMessage:", error);
                contentElem.innerHTML = `**Lỗi:** ${error.message}`;
                // If an error occurs, remove the last message (user's prompt or AI's pending message)
                // to avoid malformed history for the next attempt.
                if (localHistory.length > 0) {
                    localHistory.pop(); 
                    console.log("localHistory after error pop:", JSON.parse(JSON.stringify(localHistory)));
                }
                showToast(`Lỗi gửi tin nhắn: ${error.message}`, 'error');

            } finally {
                sendBtn.disabled = false; // Re-enable send button
            }
        }
        
        /** Saves or updates the current conversation in Firestore. */
        async function updateConversationInDb() {
            // Only save if there's a user and at least a user prompt + AI response
            if (!currentUserId || localHistory.length <= 2) return; 
            const chatData = { 
                history: localHistory, 
                updatedAt: serverTimestamp(), 
                personaId: currentPersona?.id || 'general' // Save current persona ID
            };
            try {
                if (currentChatId) {
                    // Update existing chat document
                    await updateDoc(doc(db, 'chats', currentUserId, 'conversations', currentChatId), chatData);
                } else {
                    // Create new chat document
                    // Use the first actual user prompt as the chat title
                    const firstUserPrompt = localHistory[2];
                    chatData.title = firstUserPrompt?.parts[0].text.substring(0, 40) || "Cuộc trò chuyện mới";
                    chatData.createdAt = serverTimestamp();
                    chatData.isPinned = false; // Default to not pinned
                    const docRef = await addDoc(collection(db, 'chats', currentUserId, 'conversations'), chatData);
                    currentChatId = docRef.id; // Store the new chat ID
                }
                await renderAllChats(); // Re-render sidebar chat list to show new/updated chat
            } catch (error) {
                console.error("Lỗi khi cập nhật cuộc trò chuyện:", error);
                // Consider adding a toast here if saving fails
            }
        }
        
        /**
         * Loads a specific chat conversation from Firestore.
         * @param {string} chatId - The ID of the chat to load.
         */
        async function loadChat(chatId) {
            if (speechSynthesis.speaking) speechSynthesis.cancel(); // Stop any ongoing speech
            
            // Show loading state
            personaSelectionScreen.classList.add('hidden');
            chatViewContainer.classList.remove('hidden');
            chatViewContainer.classList.add('flex');
            showHistorySkeleton(); // Show skeleton while loading
            closeSidebar(); // Close sidebar

            try {
                const chatDocRef = doc(db, 'chats', currentUserId, 'conversations', chatId);
                const chatDoc = await getDoc(chatDocRef);

                if (chatDoc.exists()) {
                    const data = chatDoc.data();
                    const loadedPersonaId = data.personaId || 'general';
                    
                    // Find the persona, or create a placeholder if it was deleted
                    let foundPersona = defaultPersonas.find(p => p.id === loadedPersonaId);
                    if (!foundPersona) {
                        const personaDocRef = doc(db, 'users', currentUserId, 'customPersonas', loadedPersonaId);
                        const personaDoc = await getDoc(personaDocRef);
                        if (personaDoc.exists()) {
                            foundPersona = { id: personaDoc.id, ...personaDoc.data() };
                        } else {
                            foundPersona = { id: 'deleted', name: 'Persona đã xóa', icon: '❓', description: '', systemPrompt: 'Hãy trả lời một cách bình thường.' };
                        }
                    }
                    currentPersona = foundPersona; // Set the loaded persona
                    updateChatHeader(currentPersona); // Update chat header
                    updateLearningModeIndicator(); // Update learning mode indicator based on chat

                    currentChatId = chatDoc.id;
                    localHistory = data.history || []; // Load history from DB
                    console.log("Loaded localHistory:", JSON.parse(JSON.stringify(localHistory)));
                    
                    await renderAllChats(); // Re-render sidebar chat list
                    welcomeScreen.classList.add('hidden');
                    welcomeScreen.classList.remove('flex');
                    chatContainer.classList.remove('hidden');
                    chatContainer.innerHTML = ''; 
                    chatContainer.appendChild(notificationArea);

                    clearSuggestions(); // Clear existing suggestions when loading a chat

                    // Display all messages from the loaded history (skipping initial system/model messages)
                    const messagesToDisplay = localHistory.slice(2);
                    messagesToDisplay.forEach(msg => {
                        addMessage(msg.role, msg.parts[0].text, false); // Don't scroll for each individual message
                    });
                    setTimeout(() => chatContainer.scrollTop = chatContainer.scrollHeight, 0); // Scroll to bottom once all messages are rendered

                    // If not in learning mode, try to get suggestions for the last AI response in the loaded chat
                    if (!isLearningMode) {
                        const lastModelMessage = localHistory.slice().reverse().find(msg => msg.role === 'model');
                        if (lastModelMessage) {
                            await getFollowUpSuggestions(lastModelMessage.parts[0].text);
                        } else {
                            clearSuggestions(); // No AI response in history, so clear suggestions
                        }
                    } else {
                        clearSuggestions(); // In learning mode, suppress general suggestions
                    }

                } else {
                    addMessage('ai', '**Lỗi:** Không tìm thấy cuộc trò chuyện.');
                    showToast('Cuộc trò chuyện không tồn tại.', 'error');
                }
            } catch (error) {
                console.error("Lỗi khi tải cuộc trò chuyện:", error);
                showToast('Lỗi khi tải cuộc trò chuyện.', 'error');
                addMessage('ai', '**Lỗi:** Không thể tải cuộc trò chuyện.');
            }
        }
        
        /** Clears the suggestion chips. */
        function clearSuggestions() {
            suggestionsContainer.innerHTML = '';
            suggestionsContainer.classList.add('hidden');
            toggleSuggestionsBtn.classList.add('hidden');
        }

        /**
         * Generates and displays follow-up suggestions based on the last AI response.
         * @param {string} lastResponse - The text of the last AI response.
         */
        async function getFollowUpSuggestions(lastResponse) {
            try {
                // Prompt for generating short, simple follow-up questions
                const suggestionPrompt = `Dựa vào câu trả lời sau: "${lastResponse.substring(0, 500)}". Hãy đề xuất 3 câu hỏi tiếp theo ngắn gọn và thú vị mà người dùng có thể hỏi. QUAN TRỌNG: Chỉ trả về 3 câu hỏi, mỗi câu trên một dòng. Không đánh số, không dùng gạch đầu dòng, không thêm bất kỳ văn bản nào khác.`;
                const result = await fastModel.generateContent(suggestionPrompt);
                const responseText = result.response.text();
                // Filter out any empty lines
                const suggestions = responseText.split('\n').filter(s => s.trim() !== '');
                displaySuggestions(suggestions);
            } catch (error) {
                console.error("Error getting suggestions:", error);
                // Do not show toast for this, as it's a background process
            }
        }

        /**
         * Handles clicking on a welcome suggestion or a follow-up suggestion.
         * Opens the reference modal and sends the suggestion text to the auxiliary assistant.
         * @param {string} suggestionText - The text of the suggestion.
         */
        async function handleSuggestionClickAndSendToReference(suggestionText) {
            // Open the reference modal and show its input area
            showReferenceModal('Trợ lý Phụ', true); 
            // Allow a tiny delay for modal to become visible before setting value to prevent race conditions
            await new Promise(resolve => setTimeout(resolve, 50)); 
            if (referencePromptInput) {
                referencePromptInput.value = suggestionText; // Set the input field
            }
            await sendReferenceMessage(suggestionText); // Send the message to the reference assistant
        }


        /**
         * Displays the generated suggestions as clickable chips.
         * @param {string[]} suggestions - An array of suggestion strings.
         */
        function displaySuggestions(suggestions) {
            suggestionsContainer.innerHTML = ''; // Clear previous suggestions
            if(suggestions.length > 0) {
                toggleSuggestionsBtn.classList.remove('hidden'); // Show toggle button
                suggestions.forEach(suggestionText => {
                    const chip = document.createElement('button');
                    chip.className = 'suggestion-chip border border-blue-200 dark:border-slate-600 bg-blue-50 dark:bg-slate-700 text-blue-700 dark:text-blue-400 rounded-full px-3 py-1 text-sm hover:bg-blue-100 dark:hover:bg-slate-600 transition-colors';
                    chip.textContent = suggestionText;
                    // Call the new helper function to handle the click
                    chip.onclick = () => { 
                        handleSuggestionClickAndSendToReference(suggestionText);
                    };
                    suggestionsContainer.appendChild(chip);
                });
            } else {
                 toggleSuggestionsBtn.classList.add('hidden'); // Hide toggle if no suggestions
            }
        }
        
        /** Generates and displays welcome suggestions on the persona selection screen. */
        async function generateWelcomeSuggestions() {
            if (!currentPersona) return; // Need a persona to generate suggestions
            // Show welcome screen and hide chat
            welcomeScreen.classList.remove('hidden');
            welcomeScreen.classList.add('flex');
            chatContainer.classList.add('hidden');

            document.getElementById('welcome-persona-icon').textContent = currentPersona.icon;
            document.getElementById('welcome-persona-name').textContent = currentPersona.name;
            document.getElementById('welcome-persona-description').textContent = currentPersona.description;
            
            const suggestionsContainer = document.getElementById('welcome-suggestions-container');
            // Show loading skeleton for welcome suggestions
            suggestionsContainer.innerHTML = `
                <div class="w-full p-4 border border-dashed dark:border-gray-700 rounded-lg animate-pulse h-12"></div>
                <div class="w-full p-4 border border-dashed dark:border-gray-700 rounded-lg animate-pulse h-12"></div>
                <div class="w-full p-4 border border-dashed dark:border-gray-700 rounded-lg animate-pulse h-12"></div>
            `;
            
            try {
                // Only generate welcome suggestions if NOT in learning mode
                if (!isLearningMode) { 
                    const prompt = `Bạn là chuyên gia về ${currentPersona.name}. Hãy tạo ra 3 câu hỏi gợi ý, ngắn gọn và thú vị mà người dùng có thể hỏi bạn để bắt đầu. Mỗi câu hỏi trên một dòng. Không dùng định dạng markdown, không đánh số hay gạch đầu dòng.`;
                    const result = await fastModel.generateContent(prompt);
                    const responseText = result.response.text();
                    const suggestions = responseText.split('\n').filter(s => s.trim() !== '');
                    
                    suggestionsContainer.innerHTML = ''; // Clear skeleton
                    suggestions.forEach(text => {
                        const card = document.createElement('button');
                        card.className = 'w-full p-4 text-left border dark:border-gray-700 rounded-lg welcome-suggestion-card';
                        card.textContent = text;
                        // Call the new helper function to handle the click
                        card.onclick = () => {
                            handleSuggestionClickAndSendToReference(text);
                        };
                        suggestionsContainer.appendChild(card);
                    });
                } else {
                    // In learning mode, show a specific message instead of suggestions
                    suggestionsContainer.innerHTML = '<p class="text-sm text-gray-500 dark:text-gray-400">Ở Chế độ Học tập, bạn sẽ nhận được các liên kết tương tác thay vì gợi ý.</p>';
                }

            } catch (error) {
                console.error("Error generating welcome suggestions:", error);
                suggestionsContainer.innerHTML = '<p class="text-sm text-gray-500 dark:text-gray-400">Không thể tải gợi ý. Vui lòng bắt đầu bằng cách nhập câu hỏi của bạn.</p>';
            }
        }

        /** Adjusts the height of the prompt input textarea based on its content. */
        function adjustInputHeight() {
            promptInput.style.height = 'auto';
            promptInput.style.height = promptInput.scrollHeight + 'px';
        }
        
        // --- Sidebar & Chat History Functions ---
        /** Opens the sidebar. */
        function openSidebar() {
            sidebar.classList.remove('-translate-x-full');
            sidebarOverlay.classList.remove('hidden');
            setTimeout(() => sidebarOverlay.classList.add('opacity-100'), 10);
        }

        /** Closes the sidebar. */
        function closeSidebar() {
            sidebar.classList.add('-translate-x-full');
            sidebarOverlay.classList.remove('opacity-100');
            setTimeout(() => sidebarOverlay.classList.add('hidden'), 300);
        }

        /** Shows a skeleton loading state in the chat area. */
        function showHistorySkeleton() {
            welcomeScreen.classList.add('hidden');
            welcomeScreen.classList.remove('flex');
            chatContainer.classList.remove('hidden');
            chatContainer.innerHTML = `<div class="w-full space-y-2">
                    <div class="flex items-center gap-2">
                        <div class="w-7 h-7 rounded-full skeleton-box"></div>
                        <div class="w-20 h-4 skeleton-box"></div>
                    </div>
                    <div class="ml-9 space-y-2">
                        <div class="w-10/12 h-4 skeleton-box"></div>
                        <div class="w-8/12 h-4 skeleton-box"></div>
                    </div>
                </div>
                <div class="flex justify-end">
                    <div class="w-7/12">
                        <div class="h-16 skeleton-box rounded-2xl"></div>
                    </div>
                </div>`;
            chatContainer.appendChild(notificationArea); // Ensure notification area is still present
        }

        /** Renders all chats in the sidebar, fetching pinned and recent chats. */
        async function renderAllChats() {
            // Only render if a user and persona are selected
            if (!currentUserId || !currentPersona) {
                savedChatsList.innerHTML = '';
                pinnedChatsList.innerHTML = '';
                pinnedChatsSection.classList.add('hidden');
                return;
            };
            isFetchingChats = false; // Reset fetching flag
            allChatsLoaded = false; // Reset loaded flag
            lastVisibleChat = null; // Reset for new fetch
            pinnedChatsList.innerHTML = ''; // Clear lists
            savedChatsList.innerHTML = '';
            await fetchPinnedChats();
            await fetchRecentChats();
        }

        /** Fetches pinned chats for the current persona. */
        async function fetchPinnedChats() {
             const chatsCollection = collection(db, 'chats', currentUserId, 'conversations');
             // Query for chats pinned to the current persona
             const q = query(chatsCollection, where('personaId', '==', currentPersona.id), where('isPinned', '==', true), orderBy('updatedAt', 'desc'));
             try {
                const querySnapshot = await getDocs(q);
                // Show/hide pinned section based on results
                pinnedChatsSection.classList.toggle('hidden', querySnapshot.empty);
                pinnedChatsList.innerHTML = ''; 
                querySnapshot.forEach(docSnap => {
                    const li = createChatItem(docSnap);
                    pinnedChatsList.appendChild(li);
                });
             }
            catch (error) {
                console.error("Lỗi khi lấy chat đã ghim (cần tạo index trên Firebase):", error);
                // Note: Firebase often requires composite indexes for queries with multiple 'where' clauses.
                // The console will provide a link to create the necessary index if missing.
            }
        }

        /**
         * Fetches recent chats for the current persona, with infinite scrolling support.
         * @param {boolean} [loadMore=false] - True to load more chats, false to load initial set.
         */
        async function fetchRecentChats(loadMore = false) {
            if (isFetchingChats || allChatsLoaded) return;
            isFetchingChats = true;
            if (!loadMore) savedChatsSkeleton.classList.remove('hidden'); // Show skeleton for initial load

            const chatsCollection = collection(db, 'chats', currentUserId, 'conversations');
            // Base query constraints for non-pinned chats of the current persona
            const constraints = [where('personaId', '==', currentPersona.id), where('isPinned', '==', false), orderBy('updatedAt', 'desc'), limit(CHATS_PER_PAGE)];
            if (lastVisibleChat && loadMore) {
                constraints.push(startAfter(lastVisibleChat)); // Start after the last visible document for pagination
            }
            const q = query(chatsCollection, ...constraints);

            try {
                const querySnapshot = await getDocs(q);
                if (!loadMore) savedChatsList.innerHTML = ''; // Clear list for initial load
                if (querySnapshot.empty && !loadMore) {
                    // Display message if no chats found and it's the initial load
                     savedChatsList.innerHTML = `
                        <li id="empty-chats-state" class="text-center p-4 space-y-2">
                            <div class="flex justify-center">
                               <svg class="w-12 h-12 text-gray-300 dark:text-gray-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M20.25 8.511c.884.284 1.5 1.128 1.5 2.097v4.286c0 1.136-.847 2.1-1.98 2.193l-3.722.267c-.427.03-.848.06-1.274.089a7.5 7.5 0 0 1-6.044-2.258 7.5 7.5 0 0 1-6.044 2.258c-.427-.029-.848-.06-1.274-.089l-3.722-.267A2.101 2.101 0 0 1 2.25 14.894V10.607c0-.97.616-1.813 1.5-2.097L6.75 8.25m.75 12.75c.621 0 1.223-.041 1.824-.121a7.5 7.5 0 017.399 0A18.75 18.75 0 0 0 22.5 21V9.75l-3.75 1.5-3.75-1.5-3.75 1.5-3.75-1.5L2.25 9.75v11.25c.621 0 1.223-.041 1.824-.121a7.5 7.5 0 017.399 0A18.75 18.75 0 0016.5 21z" /></svg>
                            </div>
                            <h4 class="font-semibold text-sm text-gray-600 dark:text-gray-300">Bắt đầu trò chuyện</h4>
                            <p class="text-xs text-gray-500 dark:text-gray-400">Các cuộc hội thoại với ${currentPersona.name} sẽ xuất hiện tại đây.</p>
                        </li>`;
                } 
                querySnapshot.forEach(docSnap => {
                    const li = createChatItem(docSnap);
                    savedChatsList.appendChild(li);
                });

                // Update lastVisibleChat for next pagination
                if (querySnapshot.docs.length > 0) {
                    lastVisibleChat = querySnapshot.docs[querySnapshot.docs.length - 1];
                }
                // If fewer docs than page size were returned, all chats are loaded
                if (querySnapshot.docs.length < CHATS_PER_PAGE) {
                    allChatsLoaded = true;
                }
            } catch (error) {
                console.error("Lỗi khi lấy lịch sử trò chuyện (cần tạo index trên Firebase):", error);
            } finally {
                isFetchingChats = false;
                savedChatsSkeleton.classList.add('hidden'); // Hide skeleton
            }
        }

        /**
         * Updates the title of a chat conversation in Firestore.
         * @param {string} chatId - The ID of the chat to update.
         * @param {string} newTitle - The new title for the chat.
         */
        async function updateChatTitle(chatId, newTitle) {
            if (!currentUserId || !newTitle) return;
            const docRef = doc(db, 'chats', currentUserId, 'conversations', chatId);
            try {
                await updateDoc(docRef, { title: newTitle });
                showToast('Tiêu đề đã được cập nhật!', 'success');
                // Re-render all chats to reflect title change and maintain order
                await renderAllChats(); 
            } catch (error) {
                console.error("Lỗi khi cập nhật tiêu đề:", error);
                showToast('Lỗi khi cập nhật tiêu đề.', 'error');
                await renderAllChats(); // Re-render in case of error to reset UI
            }
        }
        
        /**
         * Creates an HTML list item for a chat entry in the sidebar.
         * Includes logic for editing, pinning, and deleting chats.
         * @param {DocumentSnapshot} docSnap - The Firestore DocumentSnapshot of the chat.
         * @returns {HTMLElement} The created list item element.
         */
        function createChatItem(docSnap) {
            const chatItemData = docSnap.data();
            const chatId = docSnap.id;
            const li = document.createElement('li');
            li.className = "p-2 hover:bg-gray-100 dark:hover:bg-slate-700 flex justify-between items-center rounded-md group";
            li.dataset.chatId = chatId; // Store chat ID for easy access
        
            const titleContainer = document.createElement('div');
            titleContainer.className = "flex-1 truncate pr-2";
        
            const titleSpan = document.createElement('span');
            titleSpan.textContent = chatItemData.title || 'Cuộc trò chuyện mới';
            titleSpan.className = "text-gray-800 dark:text-gray-200 text-sm";
            titleContainer.appendChild(titleSpan);
        
            const titleInput = document.createElement('input');
            titleInput.type = 'text';
            titleInput.value = chatItemData.title || 'Cuộc trò chuyện mới';
            titleInput.className = "w-full bg-slate-200 dark:bg-slate-600 rounded px-1 text-sm hidden";
            titleContainer.appendChild(titleInput);
        
            li.appendChild(titleContainer);
        
            const buttonsWrapper = document.createElement('div');
            buttonsWrapper.className = 'flex items-center opacity-0 group-hover:opacity-100 transition-opacity';
        
            // Edit button
            const editBtn = document.createElement('button');
            editBtn.className = 'p-1 text-gray-400 hover:text-blue-500 rounded-full';
            editBtn.title = "Sửa tiêu đề";
            editBtn.innerHTML = `<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd" /></svg>`;
            
            const saveBtnIcon = `<svg class="w-4 h-4 text-green-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>`;
            const editBtnIcon = editBtn.innerHTML; // Store original icon

            // Pin/Unpin button
            const pinBtn = document.createElement('button');
            pinBtn.className = 'p-1 text-gray-400 hover:text-yellow-500 rounded-full';
            pinBtn.title = chatItemData.isPinned ? "Bỏ ghim" : "Ghim";
            pinBtn.innerHTML = chatItemData.isPinned ?
                `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-yellow-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5 2a1 1 0 011 1v1.586l4.707 4.707a1 1 0 010 1.414l-4.707 4.707V17a1 1 0 11-2 0v-1.586l-4.707-4.707a1 1 0 010-1.414L4 6.586V5a1 1 0 011-1zm10 0a1 1 0 011 1v1.586l4.707 4.707a1 1 0 010 1.414l-4.707 4.707V17a1 1 0 11-2 0v-1.586l-4.707-4.707a1 1 0 010-1.414L14 6.586V5a1 1 0 011-1z" clip-rule="evenodd" /></svg>` :
                `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.428a1 1 0 00.475 0l5 1.428a1 1 0 001.17-1.409l-7-14z" /></svg>`;
            
            // Delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'p-1 text-gray-400 hover:text-red-600 rounded-full';
            deleteBtn.title = "Xóa cuộc trò chuyện";
            deleteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>';
            
            buttonsWrapper.appendChild(editBtn);
            buttonsWrapper.appendChild(pinBtn);
            buttonsWrapper.appendChild(deleteBtn);
            li.appendChild(buttonsWrapper);

            // Function to toggle between display and edit mode for chat title
            const toggleEditMode = (isEditing) => {
                titleSpan.classList.toggle('hidden', isEditing);
                titleInput.classList.toggle('hidden', !isEditing);
                if (isEditing) {
                    editBtn.innerHTML = saveBtnIcon; // Change icon to save
                    editBtn.title = 'Lưu';
                    titleInput.focus(); // Focus input
                    titleInput.select(); // Select text
                } else {
                    editBtn.innerHTML = editBtnIcon; // Change icon back to edit
                    editBtn.title = 'Sửa tiêu đề';
                }
            };

            // Function to save the new title
            const saveTitle = async () => {
                const newTitle = titleInput.value.trim();
                const originalTitle = chatItemData.title || 'Cuộc trò chuyện mới';
                if (newTitle && newTitle !== originalTitle) {
                    titleSpan.textContent = newTitle; // Update displayed title immediately
                    await updateChatTitle(chatId, newTitle);
                }
                toggleEditMode(false); // Exit edit mode
            };
            
            // Event listener for edit button click
            editBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent loading chat when clicking edit
                const isEditing = !titleInput.classList.contains('hidden');
                if (isEditing) {
                    saveTitle();
                } else {
                    toggleEditMode(true);
                }
            };

            // Event listener for Enter key in title input
            titleInput.onkeydown = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) { 
                    e.preventDefault(); 
                    saveTitle(); 
                } else if (e.key === 'Escape') {
                    // Revert to original title and exit edit mode on Escape
                    titleInput.value = chatItemData.title || 'Cuộc trò chuyện mới';
                    toggleEditMode(false);
                }
            };

            // Event listener for blur (losing focus) on title input
            titleInput.addEventListener('blur', () => {
                 // Add a small delay to allow click event on save button to register first
                 setTimeout(()=> {
                     if(!titleInput.classList.contains('hidden')) {
                         saveTitle();
                     }
                 }, 100);
            });

            // Event listeners for pin and delete buttons
            pinBtn.onclick = (e) => { e.stopPropagation(); togglePinChat(chatId, chatItemData.isPinned || false); };
            deleteBtn.onclick = (e) => { e.stopPropagation(); deleteChat(chatId); };
            
            // Event listener for clicking the chat item to load the chat
            li.onclick = (e) => {
                // Prevent loading chat if clicking on the input field or if input field is active
                if (e.target === titleInput || (titleInput.classList.contains('hidden') === false && e.target !== editBtn)) return;
                loadChat(chatId);
            };

            return li;
        }


        /**
         * Toggles the pinned status of a chat conversation in Firestore.
         * @param {string} chatId - The ID of the chat to toggle.
         * @param {boolean} isCurrentlyPinned - The current pinned status.
         */
        async function togglePinChat(chatId, isCurrentlyPinned) {
            if (!currentUserId) return;
            const docRef = doc(db, 'chats', currentUserId, 'conversations', chatId);
            try {
                await updateDoc(docRef, { isPinned: !isCurrentlyPinned });
                showToast(isCurrentlyPinned ? 'Đã bỏ ghim cuộc trò chuyện.' : 'Đã ghim cuộc trò chuyện.', 'info');
                await renderAllChats(); // Re-render chat list to reflect changes
            } catch(error) {
                console.error("Lỗi khi ghim cuộc trò chuyện:", error);
                showToast('Lỗi khi ghim/bỏ ghim.', 'error');
            }
        }

        /**
         * Deletes a chat conversation from Firestore.
         * @param {string} chatId - The ID of the chat to delete.
         */
        async function deleteChat(chatId) {
            if (!confirm("Bạn có chắc chắn muốn xóa cuộc trò chuyện này?")) return;
            if (!currentUserId) return;
            try {
                await deleteDoc(doc(db, 'chats', currentUserId, 'conversations', chatId));
                showToast('Cuộc trò chuyện đã được xóa.', 'success');
                // If the currently active chat is deleted, go back to persona selection
                if(chatId === currentChatId) {
                    currentChatId = null; // Reset current chat ID
                    localHistory = []; // Clear current history
                    await showPersonaSelectionScreen();
                } else {
                    await renderAllChats(); // Otherwise, just refresh the sidebar list
                }
            } catch (error) {
                console.error("Lỗi khi xóa cuộc trò chuyện:", error);
                showToast('Lỗi khi xóa cuộc trò chuyện.', 'error');
            }
        }
        
        // --- REFERENCE MODAL FUNCTIONS ---
        /**
         * Shows the reference (auxiliary assistant) modal.
         * @param {string} title - The title for the modal header.
         * @param {boolean} showInput - Whether to show the input area in the modal.
         */
        function showReferenceModal(title, showInput) {
            referenceTitle.textContent = title;
            referenceInputArea.style.display = showInput ? 'block' : 'none';
            referenceModalOverlay.classList.remove('hidden');
            referenceModal.classList.remove('hidden');
            // If input is shown, it's a new reference conversation
            if (showInput) {
                referenceHistory = []; // Clear reference chat history
                referenceChat = fastModel.startChat({ history: [] }); // Start new session
                referenceContent.innerHTML = ''; // Clear display
                addMessageToReference('ai', 'Đây là trợ lý phụ. Bạn cần tra cứu nhanh gì không?'); // Initial greeting
            }
        }

        /** Closes the reference modal. */
        function closeReferenceModal() {
            referenceModalOverlay.classList.add('hidden');
            referenceModal.classList.add('hidden');
        }

        /**
         * Adds a message to the reference modal's chat display.
         * @param {'user'|'ai'} role - The role of the message sender.
         * @param {string} text - The content of the message.
         * @returns {{messageWrapper: HTMLElement, contentElem: HTMLElement, statusElem?: HTMLElement}}
         */
        function addMessageToReference(role, text) {
             const messageWrapper = document.createElement('div');
            let contentElem, statusElem;

            if (role === 'ai') {
                messageWrapper.className = 'w-full space-y-2';
                messageWrapper.innerHTML = `<div class="flex items-center justify-between"><div class="flex items-center gap-2"><div class="w-7 h-7 rounded-full flex-shrink-0 bg-gradient-to-tr from-green-400 to-cyan-500 flex items-center justify-center"><svg class="w-4 h-4 text-white" xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><g><rect fill="none" height="24" width="24"/></g><g><g><path d="M11,7h2v2h-2V7z M11,11h2v6h-2V11z M12,2C6.48,2,2,6.48,2,12s4.48,10,10,10s10-4.48,10-10S17.52,2,12,2z M12,20 c-4.41,0-8-3.59-8-8s3.59-8,8-8s8,3.59,8,8S16.41,20,12,20z"/></g></g></svg></div><span class="font-semibold text-gray-800 dark:text-gray-200">Trợ lý Phụ</span></div><div class="ai-status"></div></div><div class="message-content text-gray-800 dark:text-gray-200"></div><div class="message-actions mt-2 flex justify-end gap-2"></div>`;
                 contentElem = messageWrapper.querySelector('.message-content');
                 statusElem = messageWrapper.querySelector('.ai-status');
            } else {
                 messageWrapper.className = 'flex justify-end';
                messageWrapper.innerHTML = `<div class="message-content px-4 py-2 rounded-2xl bg-blue-600 text-white max-w-xs sm:max-w-md lg:max-w-2xl"></div>`;
                 contentElem = messageWrapper.querySelector('.message-content');
            }
           
            contentElem.innerHTML = DOMPurify.sanitize(marked.parse(text));
            referenceContent.appendChild(messageWrapper);
            messageWrapper.scrollIntoView({ behavior: "smooth", block: "end" });
            return { messageWrapper, contentElem, statusElem };
        }

        /**
         * Sends a message to the auxiliary assistant in the reference modal.
         * @param {string} [userPromptOverride=null] - Optional text to use as the user's prompt.
         */
        async function sendReferenceMessage(userPromptOverride = null) {
            const userPrompt = userPromptOverride || referencePromptInput.value.trim();
            if (!userPrompt) return;
            
            referenceSendBtn.disabled = true;
            if (!userPromptOverride) { // Only clear input if it came from the textarea
                referencePromptInput.value = '';
            }
            addMessageToReference('user', userPrompt);
            const { messageWrapper, contentElem } = addMessageToReference('ai', '<span class="blinking-cursor"></span>');

            try {
                // Use the dedicated reference chat session
                const result = await referenceChat.sendMessageStream(userPrompt);
                let fullResponseText = "";
                for await (const chunk of result.stream) {
                    fullResponseText += chunk.text();
                    contentElem.innerHTML = DOMPurify.sanitize(marked.parse(fullResponseText)) + '<span class="blinking-cursor"></span>';
                    referenceContent.scrollTop = referenceContent.scrollHeight; // Scroll to bottom
                }
                contentElem.innerHTML = DOMPurify.sanitize(marked.parse(fullResponseText));

                // Add "Save Note" button if there's a valid response
                const actionsContainer = messageWrapper.querySelector('.message-actions');
                if (actionsContainer && fullResponseText.trim()) {
                    const saveNoteBtn = document.createElement('button');
                    saveNoteBtn.className = 'flex items-center gap-2 text-xs px-3 py-1 bg-yellow-200 dark:bg-slate-600 text-yellow-800 dark:text-yellow-200 rounded-full hover:bg-yellow-300 dark:hover:bg-slate-500 transition-colors';
                    saveNoteBtn.innerHTML = `<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M5.433 13.917l1.262-3.155A4 0 017.58 9.42l6.92-6.918a2.121 2.121 0 013 3l-6.92 6.918c-.383.383-.84.685-1.343.886l-3.154 1.262a.5.5 0 01-.65-.65z" /><path d="M3.5 5.75c0-.69.56-1.25 1.25-1.25H10A.75.75 0 0010 3H4.75A2.75 2.75 0 002 5.75v9.5A2.75 2.75 0 004.75 18h9.5A2.75 2.75 0 0017 15.25V10a.75.75 0 00-1.5 0v5.25c0 .69-.56 1.25-1.25 1.25h-9.5c-.69 0-1.25-.56-1.25-1.25v-9.5z" /></svg> <span>Lưu Ghi chú</span>`;
                    saveNoteBtn.onclick = () => saveAsNote(userPrompt, fullResponseText);
                    actionsContainer.appendChild(saveNoteBtn);
                }
                
                // Scroll to the top of the message after a small delay
                setTimeout(() => {
                     messageWrapper.scrollIntoView({ behavior: "smooth", block: "start" });
                }, 100);

            } catch (error) {
                contentElem.innerHTML = `**Lỗi:** ${error.message}`;
                showToast('Lỗi khi gửi tin nhắn cho trợ lý phụ.', 'error');
            } finally {
                referenceSendBtn.disabled = false;
            }
        }
        
        /**
         * Saves a response from the reference modal as a 'note' in the main chat history.
         * @param {string} prompt - The user's prompt to the reference assistant.
         * @param {string} response - The reference assistant's response.
         */
        async function saveAsNote(prompt, response) {
            if (!response.trim()) return;
            const fullNoteText = `**Hỏi:** ${prompt}\n\n<hr class="my-2 border-yellow-300 dark:border-slate-600"/>\n\n**Đáp:**\n${response}`;
            const noteMessage = { role: 'note', parts: [{ text: fullNoteText }] };
            localHistory.push(noteMessage); // Add to local history
            addMessage('note', fullNoteText); // Display in main chat
            await updateConversationInDb(); // Save main chat history to DB
            closeReferenceModal(); // Close reference modal
            showToast('Đã lưu ghi chú vào cuộc trò chuyện!', 'info');
        }

        /**
         * Explains a term, either briefly or in a deep dive, using the reference modal.
         * @param {string} term - The term to explain.
         * @param {string} context - The context in which the term appeared.
         * @param {boolean} [isDeepDive=false] - Whether to provide a deep dive explanation.
         */
        async function explainTerm(term, context, isDeepDive = false) {
            if (!isDeepDive) {
                showReferenceModal(`Giải thích: ${term}`, false); // Show modal without input for quick explanation
            }
            referenceContent.innerHTML = ''; // Clear previous content in reference modal
            
            const prompt = isDeepDive 
                ? `Hãy giải thích chuyên sâu về thuật ngữ "${term}", bao gồm định nghĩa đầy đủ, ví dụ cụ thể, và các ứng dụng chính của nó.`
                : `Trong ngữ cảnh của câu sau: "${context.substring(0, 500)}", hãy giải thích thuật ngữ "${term}" một cách ngắn gọn và dễ hiểu trong 1-2 câu.`;

            const { contentElem, messageWrapper, statusElem } = addMessageToReference('ai', '<span class="blinking-cursor"></span>');
            if (statusElem) {
                statusElem.textContent = 'Đang suy nghĩ...';
                statusElem.classList.remove('hidden');
            }
            
            try {
                const result = await fastModel.generateContent(prompt);
                const responseText = result.response.text();
                if(statusElem) statusElem.classList.add('hidden');
                contentElem.innerHTML = DOMPurify.sanitize(marked.parse(responseText));

                // Add "Deep Dive" button if not already in deep dive mode
                if (!isDeepDive) {
                    const actionsContainer = messageWrapper.querySelector('.message-actions');
                    if(actionsContainer){
                        const deepDiveBtn = document.createElement('button');
                        deepDiveBtn.className = 'flex items-center gap-2 text-xs px-3 py-1 bg-blue-100 dark:bg-slate-600 text-blue-800 dark:text-blue-200 rounded-full hover:bg-blue-200 dark:hover:bg-slate-500 transition-colors';
                        deepDiveBtn.innerHTML = `<span>Tìm hiểu sâu hơn</span> 📖`;
                        deepDiveBtn.onclick = () => explainTerm(term, context, true); // Call again for deep dive
                        actionsContainer.appendChild(deepDiveBtn);
                    }
                }

            } catch (error) {
                 if(statusElem) statusElem.classList.add('hidden');
                contentElem.innerHTML = `**Lỗi:** ${error.message}`;
                showToast('Không thể giải thích thuật ngữ.', 'error');
            }
        }

        /** Generates a system prompt for a custom persona using AI. */
        async function generateSystemPrompt() {
            const name = personaNameInput.value.trim();
            const description = personaDescriptionInput.value.trim();

            if (!name || !description) {
                showToast('Vui lòng nhập Tên và Mô tả ngắn.', 'error');
                return;
            }

            const originalBtnContent = generatePromptBtn.innerHTML;
            generatePromptBtn.innerHTML = `<svg class="w-5 h-5 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
            generatePromptBtn.disabled = true;

            try {
                // Prompt the AI to generate a detailed system prompt for the persona
                const prompt = `Dựa trên một chuyên gia có tên là '${name}' và mô tả '${description}', hãy viết một Chỉ thị Hệ thống (System Prompt) chi tiết và chuyên nghiệp bằng tiếng Việt. Chỉ thị này cần bao gồm: phong cách, quy tắc hoạt động, và các yêu cầu về định dạng đầu ra. **Yêu cầu bổ sung:** Trong quá trình trả lời, khi bạn đề cập đến một thuật ngữ kỹ thuật, một khái niệm quan trọng, hoặc một tên riêng, hãy bọc thuật ngữ đó trong cặp dấu ngoặc vuông để có thể nhấp để giải thích thêm. Ví dụ: 'sử dụng ngôn ngữ [Python] để phát triển [backend]'.`;
                const result = await fastModel.generateContent(prompt);
                personaPromptInput.value = result.response.text();
            } catch (error) {
                console.error("Lỗi khi tạo gợi ý prompt:", error);
                personaPromptInput.value = "Rất tiếc, không thể tạo gợi ý lúc này. Vui lòng thử lại.";
                showToast('Không thể tạo gợi ý prompt.', 'error');
            } finally {
                generatePromptBtn.innerHTML = originalBtnContent;
                generatePromptBtn.disabled = false;
            }
        }
        
        /**
         * Handles the click event on a learning mode interactive link.
         * Sends the associated prompt to the main AI model.
         * @param {HTMLElement} linkElement - The clicked `<a>` element.
         */
        async function handleLearningPromptClick(linkElement) {
            const promptForAI = linkElement.dataset.prompt;
            if (!promptForAI) return;

            // The user-facing text is the link's title
            const titleForDisplay = linkElement.textContent;
            
            // Re-use the sendMessage function, passing the detailed prompt as an override.
            // The `titleForDisplay` is passed as the first argument, so it's what gets
            // displayed as the "user" message in the main chat. The actual `promptForAI`
            // is then used for the AI model call.
            await sendMessage(titleForDisplay); // Send title to display as user message
        }

        // --- GLOBAL EVENT LISTENERS ---
        createPersonaBtn.addEventListener('click', () => openPersonaModal());
        closePersonaModalBtn.addEventListener('click', closePersonaModal);
        cancelPersonaBtn.addEventListener('click', closePersonaModal);
        personaModalOverlay.addEventListener('click', closePersonaModal);
        personaForm.addEventListener('submit', handleSavePersona);
        generatePromptBtn.addEventListener('click', generateSystemPrompt);
        newChatBtn.addEventListener('click', showPersonaSelectionScreen);
        newTopicBtn.addEventListener('click', () => {
            if (currentPersona) {
                // Start a new chat with the *current* persona, detecting if it's custom
                startNewChat(currentPersona.id, !!currentPersona.ownerId);
            } else {
                showPersonaSelectionScreen(); // If no persona selected, go to selection screen
            }
        });
        summarizeBtn.addEventListener('click', handleSummary);
        sendBtn.addEventListener('click', () => sendMessage());
        promptInput.addEventListener('keydown', e => { 
            if (e.key === 'Enter' && !e.shiftKey) { 
                e.preventDefault(); 
                sendMessage(); 
            } 
        });
        promptInput.addEventListener('input', adjustInputHeight);
        menuBtn.addEventListener('click', openSidebar);
        closeSidebarBtn.addEventListener('click', closeSidebar);
        sidebarOverlay.addEventListener('click', closeSidebar);
        toggleSuggestionsBtn.addEventListener('click', () => suggestionsContainer.classList.toggle('hidden'));
        referenceBtn.addEventListener('click', () => showReferenceModal('Trợ lý Phụ', true));
        closeReferenceModalBtn.addEventListener('click', closeReferenceModal);
        referenceModalOverlay.addEventListener('click', closeReferenceModal);
        referenceSendBtn.addEventListener('click', () => sendReferenceMessage());
        referencePromptInput.addEventListener('keydown', e => { 
            if (e.key === 'Enter' && !e.shiftKey) { 
                e.preventDefault(); 
                sendReferenceMessage(); 
            } 
        });
        
        /** Updates the visibility of the learning mode indicator in the chat header. */
        function updateLearningModeIndicator() {
            // Check if element exists before manipulating
            if (learningModeIndicator) { 
                if (isLearningMode) {
                    learningModeIndicator.classList.remove('hidden');
                } else {
                    learningModeIndicator.classList.add('hidden');
                }
            }
        }

        learningModeToggle.addEventListener('change', async (e) => { 
            isLearningMode = e.target.checked;
            showToast(`Chế độ Học tập đã được ${isLearningMode ? 'bật' : 'tắt'}.`, 'info');
            updateLearningModeIndicator(); // Update indicator state

            if (isLearningMode) {
                clearSuggestions(); // Always hide regular suggestions in learning mode
                // If we are on the welcome screen, update welcome suggestions to show learning mode message
                if (!chatContainer.classList.contains('hidden') && currentChatId === null) { 
                    await generateWelcomeSuggestions(); 
                } else if (chatContainer.classList.contains('hidden') && currentPersona) {
                    // If on persona selection and a persona is implicitly active (e.g. going back to it)
                    // refresh the persona's welcome screen
                    await generateWelcomeSuggestions(); 
                }
            } else {
                // When exiting learning mode, try to get suggestions for the last AI response
                // Only if there's an existing chat and a previous AI response to get suggestions from
                if (currentChatId) { 
                    const lastModelMessage = localHistory.slice().reverse().find(msg => msg.role === 'model');
                    if (lastModelMessage) {
                        await getFollowUpSuggestions(lastModelMessage.parts[0].text);
                    } else {
                        clearSuggestions(); // No AI response yet, so clear suggestions
                    }
                } else if (currentPersona) {
                    // If exiting learning mode on persona selection screen and a persona is active
                    await generateWelcomeSuggestions(); 
                } else {
                    clearSuggestions(); // No active chat or persona, so just clear suggestions
                }
            }
        });

        /** Resets the state of the active speech synthesis button. */
        function resetActiveSpeechButton() {
            if (activeSpeech && activeSpeech.button) {
                activeSpeech.button.innerHTML = '🔊';
                activeSpeech.button.dataset.state = 'idle';
                activeSpeech.button.title = 'Đọc văn bản';
            }
        }

        // Main click handler for the chat container to handle dynamic links/buttons
        chatContainer.addEventListener('click', async (e) => {
            const link = e.target.closest('a');
            const button = e.target.closest('button');

            if (link) {
                e.preventDefault();
                e.stopPropagation();
                if (link.classList.contains('learning-link')) {
                    await handleLearningPromptClick(link);
                } else if (link.classList.contains('term-link')) {
                    const term = link.dataset.term;
                    const messageContentElement = link.closest('.message-content');
                    const context = messageContentElement ? messageContentElement.dataset.rawText : '';
                    await explainTerm(term, context);
                }
            } else if (button) {
                 if (button.classList.contains('copy-btn')) {
                    e.preventDefault(); e.stopPropagation();
                    copyToClipboard(button.dataset.text);
                 } else if (button.classList.contains('speak-btn')) {
                    e.preventDefault(); e.stopPropagation();
                    // Handle Speech Synthesis
                    if (speechSynthesis.speaking || speechSynthesis.paused) {
                        if (activeSpeech && activeSpeech.button === button) {
                            const currentState = button.dataset.state;
                            if (currentState === 'paused') {
                                speechSynthesis.resume();
                                button.innerHTML = '⏸️'; button.dataset.state = 'playing'; button.title = 'Tạm dừng';
                                return;
                            }
                            if (currentState === 'playing') {
                                speechSynthesis.pause();
                                button.innerHTML = '▶️'; button.dataset.state = 'Tiếp tục';
                                return;
                            }
                        }
                        speechSynthesis.cancel(); // Cancel any current speech if new button is clicked
                    }

                    const utterance = new SpeechSynthesisUtterance(button.dataset.text);
                    utterance.lang = 'vi-VN'; // Set language to Vietnamese
                    utterance.onstart = () => {
                        resetActiveSpeechButton(); // Reset previous button state
                        activeSpeech = { utterance, button: button }; // Set current active speech
                        button.innerHTML = '⏸️'; button.dataset.state = 'playing'; button.title = 'Tạm dừng';
                    };
                    utterance.onend = () => { resetActiveSpeechButton(); activeSpeech = null; };
                    utterance.onerror = (event) => { 
                        console.error("SpeechSynthesisUtterance error:", event);
                        showToast(`Lỗi phát âm: ${event.error}`, 'error'); // Show error message
                        resetActiveSpeechButton(); 
                        activeSpeech = null; 
                    };
                    speechSynthesis.speak(utterance);
                 }
            }
        });

        // Event listener for infinite scrolling in sidebar
        sidebarContent.addEventListener('scroll', () => {
            const isNearBottom = sidebarContent.scrollHeight - sidebarContent.scrollTop - sidebarContent.clientHeight < 100;
            if (isNearBottom && !isFetchingChats && !allChatsLoaded) {
                fetchRecentChats(true); // Load more chats if near bottom
            }
        });

        // Initialize Speech Recognition
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if(SpeechRecognition) {
            const recognition = new SpeechRecognition();
            recognition.continuous = false; // Stop after a single utterance
            recognition.lang = 'vi-VN'; // Vietnamese language
            recognition.interimResults = false; // Only return final results

            recognition.onstart = () => { 
                isRecording = true; 
                recordBtn.classList.add('recording'); 
                promptInput.placeholder = 'Đang lắng nghe...'; 
            };
            recognition.onend = () => { 
                isRecording = false; 
                recordBtn.classList.remove('recording'); 
                promptInput.placeholder = 'Nhập câu hỏi...'; 
            };
            recognition.onresult = (event) => { 
                promptInput.value = event.results[event.results.length - 1][0].transcript.trim(); 
                adjustInputHeight(); 
                sendMessage(); 
            };
            recognition.onerror = (event) => { 
                showToast(`Lỗi ghi âm: ${event.error}`, 'error'); 
                console.error("Speech Recognition error:", event.error);
            };
            recordBtn.addEventListener('click', () => { 
                isRecording ? recognition.stop() : recognition.start(); 
            });
        } else { 
            recordBtn.classList.add('hidden'); // Hide record button if API not supported
        }

        // --- Scroll to Top Button Logic ---
        const scrollThreshold = 300; // Show button after scrolling 300px

        /** Function to show/hide the scroll to top button. */
        function toggleScrollToTopButton() {
            // Ensure scrollToTopBtn is available. This check handles cases where DOMContentLoaded
            // might fire before the element is fully processed or if the element is missing.
            if (!scrollToTopBtn || !chatScrollContainer) return; 

            // Show when scrolled down more than half the container's visible height
            if (chatScrollContainer.scrollTop > chatScrollContainer.clientHeight * 0.5) { 
                scrollToTopBtn.classList.add('show');
            } else {
                scrollToTopBtn.classList.remove('show');
            }
        }

        /** Function to scroll to the top of the chat container. */
        function scrollToTop() {
            if (chatScrollContainer) {
                chatScrollContainer.scrollTo({
                    top: 0,
                    behavior: "smooth" // Smooth scrolling
                });
            }
        }

        // Event listeners for scroll and button click on the chat container
        document.addEventListener('DOMContentLoaded', () => {
            // Attach event listeners only if elements exist
            if (chatScrollContainer) {
                chatScrollContainer.addEventListener("scroll", toggleScrollToTopButton);
            }
            if (scrollToTopBtn) { 
                scrollToTopBtn.addEventListener("click", scrollToTop);
            }
            updateLearningModeIndicator(); // Initial update for the indicator state
        });

    </script>
    <!-- Commented out Service Worker registration as it causes errors in this environment without a proper service-worker.js file. -->
    <!-- <script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", function () {
      navigator.serviceWorker.register("./service-worker.js")
        .then(reg => console.log("SW registered:", reg.scope))
        .catch(err => console.error("SW registration failed:", err));
    });
  }
</script> -->
</body>
</html>
